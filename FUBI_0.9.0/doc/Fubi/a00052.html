<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Fubi: FUBI C++ API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doc.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fubi
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FUBI C++ API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae213ab15ce900f6b9306b6fd8fa8ec16"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gae213ab15ce900f6b9306b6fd8fa8ec16">Fubi::init</a> (const char *openniXmlconfig=0x0, Fubi::SkeletonTrackingProfile::Profile profile=Fubi::SkeletonTrackingProfile::ALL, float filterMinCutOffFrequency=1.0f, float filterVelocityCutOffFrequency=1.0f, float filterCutOffSlope=0.007f, bool mirrorStreams=true, bool registerStreams=true)</td></tr>
<tr class="memdesc:gae213ab15ce900f6b9306b6fd8fa8ec16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> with OpenN 1.x using the given xml file and sets the skeleton profile. If no xml file is given, <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> will be intialized without OpenNI tracking enabled &ndash;&gt; methods that need an openni context won't work.  <a href="#gae213ab15ce900f6b9306b6fd8fa8ec16">More...</a><br/></td></tr>
<tr class="separator:gae213ab15ce900f6b9306b6fd8fa8ec16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cf0e80e814ff42a8bb1d72faa63624"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaa2cf0e80e814ff42a8bb1d72faa63624">Fubi::init</a> (const SensorOptions &amp;sensorOptions, const FilterOptions &amp;filterOptions=FilterOptions())</td></tr>
<tr class="memdesc:gaa2cf0e80e814ff42a8bb1d72faa63624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> with an options file for the sensor init.  <a href="#gaa2cf0e80e814ff42a8bb1d72faa63624">More...</a><br/></td></tr>
<tr class="separator:gaa2cf0e80e814ff42a8bb1d72faa63624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff24edb1c70ec72965812578c9a33cdf"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaff24edb1c70ec72965812578c9a33cdf">Fubi::init</a> (int depthWidth, int depthHeight, int depthFPS=30, int rgbWidth=640, int rgbHeight=480, int rgbFPS=30, int irWidth=-1, int irHeight=-1, int irFPS=-1, <a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921e">Fubi::SensorType::Type</a> sensorType=<a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921eabd46c2311df377fae2ae9c3994365fe5">Fubi::SensorType::OPENNI2</a>, <a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3">Fubi::SkeletonTrackingProfile::Profile</a> profile=<a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3a7f53042d38ba34fa228a2b6c684984a5">Fubi::SkeletonTrackingProfile::ALL</a>, float filterMinCutOffFrequency=1.0f, float filterVelocityCutOffFrequency=1.0f, float filterCutOffSlope=0.007f, bool mirrorStream=true, bool registerStreams=true)</td></tr>
<tr class="memdesc:gaff24edb1c70ec72965812578c9a33cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> with specific options for the sensor init.  <a href="#gaff24edb1c70ec72965812578c9a33cdf">More...</a><br/></td></tr>
<tr class="separator:gaff24edb1c70ec72965812578c9a33cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcb55d542e517d4aa5e105f93e1421c"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga2bcb55d542e517d4aa5e105f93e1421c">Fubi::switchSensor</a> (const SensorOptions &amp;options)</td></tr>
<tr class="memdesc:ga2bcb55d542e517d4aa5e105f93e1421c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to switch between different sensor types during runtime Note that this will also reinitialize most parts of <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a>.  <a href="#ga2bcb55d542e517d4aa5e105f93e1421c">More...</a><br/></td></tr>
<tr class="separator:ga2bcb55d542e517d4aa5e105f93e1421c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ecfd12445e1749668d5ec4e8616015"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga28ecfd12445e1749668d5ec4e8616015">Fubi::switchSensor</a> (<a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921e">Fubi::SensorType::Type</a> sensorType, int depthWidth, int depthHeight, int depthFPS=30, int rgbWidth=640, int rgbHeight=480, int rgbFPS=30, int irWidth=-1, int irHeight=-1, int irFPS=-1, <a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3">Fubi::SkeletonTrackingProfile::Profile</a> profile=<a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3a7f53042d38ba34fa228a2b6c684984a5">Fubi::SkeletonTrackingProfile::ALL</a>, bool mirrorStream=true, bool registerStreams=true)</td></tr>
<tr class="memdesc:ga28ecfd12445e1749668d5ec4e8616015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to switch between different sensor types during runtime Note that this will also reinitialize most parts of <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a>.  <a href="#ga28ecfd12445e1749668d5ec4e8616015">More...</a><br/></td></tr>
<tr class="separator:ga28ecfd12445e1749668d5ec4e8616015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2a97d9834d1921bcca827633ed7071"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaab2a97d9834d1921bcca827633ed7071">Fubi::getAvailableSensorTypes</a> ()</td></tr>
<tr class="memdesc:gaab2a97d9834d1921bcca827633ed7071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently available sensor types (defined in <a class="el" href="a00040.html" title="a header file containing defines for configuring the Fubi build ">FubiConfig.h</a> before compilation)  <a href="#gaab2a97d9834d1921bcca827633ed7071">More...</a><br/></td></tr>
<tr class="separator:gaab2a97d9834d1921bcca827633ed7071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3a6930abb4fec54c139fb5c0502856"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921e">Fubi::SensorType::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga7e3a6930abb4fec54c139fb5c0502856">Fubi::getCurrentSensorType</a> ()</td></tr>
<tr class="memdesc:ga7e3a6930abb4fec54c139fb5c0502856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the currently active sensor.  <a href="#ga7e3a6930abb4fec54c139fb5c0502856">More...</a><br/></td></tr>
<tr class="separator:ga7e3a6930abb4fec54c139fb5c0502856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa422b77cda7f191b315b061e7a997409"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaa422b77cda7f191b315b061e7a997409">Fubi::release</a> ()</td></tr>
<tr class="memdesc:gaa422b77cda7f191b315b061e7a997409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down OpenNI and the tracker, releasing all allocated memory.  <a href="#gaa422b77cda7f191b315b061e7a997409">More...</a><br/></td></tr>
<tr class="separator:gaa422b77cda7f191b315b061e7a997409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e26bd58ab074f4e01bfd211d1d65af"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gad7e26bd58ab074f4e01bfd211d1d65af">Fubi::isInitialized</a> ()</td></tr>
<tr class="memdesc:gad7e26bd58ab074f4e01bfd211d1d65af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if OpenNI has been already initialized.  <a href="#gad7e26bd58ab074f4e01bfd211d1d65af">More...</a><br/></td></tr>
<tr class="separator:gad7e26bd58ab074f4e01bfd211d1d65af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb391d7b7f9fceb7b2d3c421a5d70de7"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaeb391d7b7f9fceb7b2d3c421a5d70de7">Fubi::updateSensor</a> ()</td></tr>
<tr class="memdesc:gaeb391d7b7f9fceb7b2d3c421a5d70de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the sensor to get the next frame of depth, rgb, and tracking data. Also searches for users in the scene and loads the default tracking calibration for new users or request a calibration.  <a href="#gaeb391d7b7f9fceb7b2d3c421a5d70de7">More...</a><br/></td></tr>
<tr class="separator:gaeb391d7b7f9fceb7b2d3c421a5d70de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec29fdfbe5e3e592f1cdbbb752292ef9"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaec29fdfbe5e3e592f1cdbbb752292ef9">Fubi::getImage</a> (unsigned char *outputImage, ImageType::Type type, ImageNumChannels::Channel numChannels, ImageDepth::Depth depth, int renderOptions=(RenderOptions::Shapes|RenderOptions::Skeletons|RenderOptions::UserCaptions), int jointsToRender=RenderOptions::ALL_JOINTS, DepthImageModification::Modification depthModifications=DepthImageModification::UseHistogram, unsigned int userId=0, Fubi::SkeletonJoint::Joint jointOfInterest=Fubi::SkeletonJoint::NUM_JOINTS, bool moveCroppedToUpperLeft=false)</td></tr>
<tr class="memdesc:gaec29fdfbe5e3e592f1cdbbb752292ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve an image from one of the OpenNI production nodes with specific format and optionally enhanced by different tracking information Some render options require an OpenCV installation!  <a href="#gaec29fdfbe5e3e592f1cdbbb752292ef9">More...</a><br/></td></tr>
<tr class="separator:gaec29fdfbe5e3e592f1cdbbb752292ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cab8087177c391cdb87302914ea478"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaa2cab8087177c391cdb87302914ea478">Fubi::saveImage</a> (const char *fileName, int jpegQuality, ImageType::Type type, ImageNumChannels::Channel numChannels, ImageDepth::Depth depth, int renderOptions=(RenderOptions::Shapes|RenderOptions::Skeletons|RenderOptions::UserCaptions), int jointsToRender=RenderOptions::ALL_JOINTS, DepthImageModification::Modification depthModifications=DepthImageModification::UseHistogram, unsigned int userId=0, Fubi::SkeletonJoint::Joint jointOfInterest=Fubi::SkeletonJoint::NUM_JOINTS)</td></tr>
<tr class="memdesc:gaa2cab8087177c391cdb87302914ea478"><td class="mdescLeft">&#160;</td><td class="mdescRight">save an image from one of the OpenNI production nodes with specific format and optionally enhanced by different tracking information  <a href="#gaa2cab8087177c391cdb87302914ea478">More...</a><br/></td></tr>
<tr class="separator:gaa2cab8087177c391cdb87302914ea478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5631a7559e0abb1ff68ffbb98b11ccf5"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga5631a7559e0abb1ff68ffbb98b11ccf5">Fubi::recognizeGestureOn</a> (Postures::Posture postureID, unsigned int userID)</td></tr>
<tr class="memdesc:ga5631a7559e0abb1ff68ffbb98b11ccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to recognize a posture in the current frame of tracking data of one user.  <a href="#ga5631a7559e0abb1ff68ffbb98b11ccf5">More...</a><br/></td></tr>
<tr class="separator:ga5631a7559e0abb1ff68ffbb98b11ccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2994bb1130c06498be9bee9a274aefb1"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga2994bb1130c06498be9bee9a274aefb1">Fubi::recognizeGestureOn</a> (unsigned int recognizerIndex, unsigned int userID, <a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *correctionHint=0x0)</td></tr>
<tr class="memdesc:ga2994bb1130c06498be9bee9a274aefb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined gesture or posture recognizer for its success.  <a href="#ga2994bb1130c06498be9bee9a274aefb1">More...</a><br/></td></tr>
<tr class="separator:ga2994bb1130c06498be9bee9a274aefb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1254f7661042229bb7a7d629ba91fdf2"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga1254f7661042229bb7a7d629ba91fdf2">Fubi::recognizeGestureOn</a> (const char *recognizerName, unsigned int userID, <a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *correctionHint=0x0)</td></tr>
<tr class="memdesc:ga1254f7661042229bb7a7d629ba91fdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined gesture or posture recognizer for its success.  <a href="#ga1254f7661042229bb7a7d629ba91fdf2">More...</a><br/></td></tr>
<tr class="separator:ga1254f7661042229bb7a7d629ba91fdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdb51f689c1c86a3c3eeb9fe71c73ce"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga7fdb51f689c1c86a3c3eeb9fe71c73ce">Fubi::getCombinationRecognitionProgressOn</a> (Combinations::Combination combinationID, unsigned int userID, std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *userStates=0x0, bool restart=true, bool returnFilteredData=false, Fubi::RecognitionCorrectionHint *correctionHint=0x0)</td></tr>
<tr class="memdesc:ga7fdb51f689c1c86a3c3eeb9fe71c73ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a combination recognizer for its progress.  <a href="#ga7fdb51f689c1c86a3c3eeb9fe71c73ce">More...</a><br/></td></tr>
<tr class="separator:ga7fdb51f689c1c86a3c3eeb9fe71c73ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56edfa3727aa96bfc56e264f5f2ec58a"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga56edfa3727aa96bfc56e264f5f2ec58a">Fubi::getCombinationRecognitionProgressOn</a> (const char *recognizerName, unsigned int userID, std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *userStates=0x0, bool restart=true, bool returnFilteredData=false, Fubi::RecognitionCorrectionHint *correctionHint=0x0)</td></tr>
<tr class="memdesc:ga56edfa3727aa96bfc56e264f5f2ec58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined combination recognizer for its progress.  <a href="#ga56edfa3727aa96bfc56e264f5f2ec58a">More...</a><br/></td></tr>
<tr class="separator:ga56edfa3727aa96bfc56e264f5f2ec58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf24b874ac9061d1e022e1a5eb803429"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaaf24b874ac9061d1e022e1a5eb803429">Fubi::enableCombinationRecognition</a> (Combinations::Combination combinationID, unsigned int userID, bool enable)</td></tr>
<tr class="memdesc:gaaf24b874ac9061d1e022e1a5eb803429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts or stops the recognition process of a combination for one user.  <a href="#gaaf24b874ac9061d1e022e1a5eb803429">More...</a><br/></td></tr>
<tr class="separator:gaaf24b874ac9061d1e022e1a5eb803429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92918d879eb3111178cd04f05b39f7a1"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga92918d879eb3111178cd04f05b39f7a1">Fubi::enableCombinationRecognition</a> (const char *combinationName, unsigned int userID, bool enable)</td></tr>
<tr class="memdesc:ga92918d879eb3111178cd04f05b39f7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts or stops the recognition process of a user defined combination for one user.  <a href="#ga92918d879eb3111178cd04f05b39f7a1">More...</a><br/></td></tr>
<tr class="separator:ga92918d879eb3111178cd04f05b39f7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89012c22cf6b53abc71f7ce0a4f6911b"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga89012c22cf6b53abc71f7ce0a4f6911b">Fubi::setAutoStartCombinationRecognition</a> (bool enable, Combinations::Combination combinationID=Combinations::NUM_COMBINATIONS)</td></tr>
<tr class="memdesc:ga89012c22cf6b53abc71f7ce0a4f6911b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically starts combination recogntion for new users.  <a href="#ga89012c22cf6b53abc71f7ce0a4f6911b">More...</a><br/></td></tr>
<tr class="separator:ga89012c22cf6b53abc71f7ce0a4f6911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05e1acf8f3abce0225ab7dae712f37d"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaf05e1acf8f3abce0225ab7dae712f37d">Fubi::getAutoStartCombinationRecognition</a> (Combinations::Combination combinationID=Combinations::NUM_COMBINATIONS)</td></tr>
<tr class="memdesc:gaf05e1acf8f3abce0225ab7dae712f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if autostart is activated for a combination recognizer.  <a href="#gaf05e1acf8f3abce0225ab7dae712f37d">More...</a><br/></td></tr>
<tr class="separator:gaf05e1acf8f3abce0225ab7dae712f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6825ee1823b821489ef8273c8d3b0010"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga6825ee1823b821489ef8273c8d3b0010">Fubi::getColorForUserID</a> (unsigned int id, float &amp;r, float &amp;g, float &amp;b)</td></tr>
<tr class="memdesc:ga6825ee1823b821489ef8273c8d3b0010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the color for a user in the background image.  <a href="#ga6825ee1823b821489ef8273c8d3b0010">More...</a><br/></td></tr>
<tr class="separator:ga6825ee1823b821489ef8273c8d3b0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb2308cb44ebc2930c55643ca29a8bf"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gadcb2308cb44ebc2930c55643ca29a8bf">Fubi::getUserID</a> (unsigned int index)</td></tr>
<tr class="memdesc:gadcb2308cb44ebc2930c55643ca29a8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns user id from the user index.  <a href="#gadcb2308cb44ebc2930c55643ca29a8bf">More...</a><br/></td></tr>
<tr class="separator:gadcb2308cb44ebc2930c55643ca29a8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43737fba1941a25879985a8b0b054c5f"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga43737fba1941a25879985a8b0b054c5f">Fubi::addJointRelationRecognizer</a> (SkeletonJoint::Joint joint, SkeletonJoint::Joint relJoint, float minX=-Fubi::Math::MaxFloat, float minY=-Fubi::Math::MaxFloat, float minZ=-Fubi::Math::MaxFloat, float maxX=Fubi::Math::MaxFloat, float maxY=Fubi::Math::MaxFloat, float maxZ=Fubi::Math::MaxFloat, float minDistance=0, float maxDistance=Fubi::Math::MaxFloat, bool useLocalPositions=false, int atIndex=-1, const char *name=0, float minConfidence=-1.0f, Fubi::BodyMeasurement::Measurement measuringUnit=Fubi::BodyMeasurement::NUM_MEASUREMENTS, bool useFilteredData=false)</td></tr>
<tr class="memdesc:ga43737fba1941a25879985a8b0b054c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined joint relation recognizer.  <a href="#ga43737fba1941a25879985a8b0b054c5f">More...</a><br/></td></tr>
<tr class="separator:ga43737fba1941a25879985a8b0b054c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cc6f574195ac649fac5998f1ac4854"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga46cc6f574195ac649fac5998f1ac4854">Fubi::addJointOrientationRecognizer</a> (Fubi::SkeletonJoint::Joint joint, float minX=-180.0f, float minY=-180.0f, float minZ=-180.0f, float maxX=180.0f, float maxY=180.0f, float maxZ=180.0f, bool useLocalOrientations=true, int atIndex=-1, const char *name=0, float minConfidence=-1, bool useFilteredData=false)</td></tr>
<tr class="memdesc:ga46cc6f574195ac649fac5998f1ac4854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined joint orientation recognizer.  <a href="#ga46cc6f574195ac649fac5998f1ac4854">More...</a><br/></td></tr>
<tr class="separator:ga46cc6f574195ac649fac5998f1ac4854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3ced0dc57ca4a4b17d78a064abca76"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gadb3ced0dc57ca4a4b17d78a064abca76">Fubi::addJointOrientationRecognizer</a> (Fubi::SkeletonJoint::Joint joint, float orientX, float orientY, float orientZ, float maxAngleDifference=45.0f, bool useLocalOrientations=true, int atIndex=-1, const char *name=0, float minConfidence=-1, bool useFilteredData=false)</td></tr>
<tr class="memdesc:gadb3ced0dc57ca4a4b17d78a064abca76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined joint orientation recognizer.  <a href="#gadb3ced0dc57ca4a4b17d78a064abca76">More...</a><br/></td></tr>
<tr class="separator:gadb3ced0dc57ca4a4b17d78a064abca76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a2707828a308832cf62c4d9f277683"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaf3a2707828a308832cf62c4d9f277683">Fubi::addFingerCountRecognizer</a> (Fubi::SkeletonJoint::Joint handJoint, unsigned int minFingers, unsigned int maxFingers, int atIndex=-1, const char *name=0, float minConfidence=-1, bool useMedianCalculation=false, bool useFilteredData=false)</td></tr>
<tr class="memdesc:gaf3a2707828a308832cf62c4d9f277683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined finger count recognizer.  <a href="#gaf3a2707828a308832cf62c4d9f277683">More...</a><br/></td></tr>
<tr class="separator:gaf3a2707828a308832cf62c4d9f277683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf1289a004219995363502680bef410"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gafcf1289a004219995363502680bef410">Fubi::addLinearMovementRecognizer</a> (SkeletonJoint::Joint joint, SkeletonJoint::Joint relJoint, float dirX, float dirY, float dirZ, float minVel, float maxVel=Fubi::Math::MaxFloat, bool useLocalPositions=false, int atIndex=-1, const char *name=0, float maxAngleDifference=45.0f, bool useOnlyCorrectDirectionComponent=true, bool useFilteredData=false)</td></tr>
<tr class="memdesc:gafcf1289a004219995363502680bef410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined linear movement recognizer A linear gesture has a vector calculated as joint - relative joint, the direction (each component -1 to +1) that will be applied per component on the vector, and a min and max vel in milimeter per second.  <a href="#gafcf1289a004219995363502680bef410">More...</a><br/></td></tr>
<tr class="separator:gafcf1289a004219995363502680bef410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d037617c70a45b80664e4fe5f34be1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d037617c70a45b80664e4fe5f34be1c"></a>
FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>Fubi::addLinearMovementRecognizer</b> (SkeletonJoint::Joint joint, float dirX, float dirY, float dirZ, float minVel, float maxVel=Fubi::Math::MaxFloat, bool useLocalPositions=false, int atIndex=-1, const char *name=0, float maxAngleDifference=45.0f, bool useOnlyCorrectDirectionComponent=true, bool useFilteredData=false)</td></tr>
<tr class="separator:ga4d037617c70a45b80664e4fe5f34be1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77888b204d844c3db95128488615465"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gac77888b204d844c3db95128488615465">Fubi::addLinearMovementRecognizer</a> (SkeletonJoint::Joint joint, SkeletonJoint::Joint relJoint, float dirX, float dirY, float dirZ, float minVel, float maxVel, float minLength, float maxLength=Fubi::Math::MaxFloat, Fubi::BodyMeasurement::Measurement measuringUnit=Fubi::BodyMeasurement::NUM_MEASUREMENTS, bool useLocalPositions=false, int atIndex=-1, const char *name=0, float maxAngleDifference=45.0f, bool useOnlyCorrectDirectionComponent=true, bool useFilteredData=false)</td></tr>
<tr class="memdesc:gac77888b204d844c3db95128488615465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined linear movement recognizer A linear gesture has a vector calculated as joint - relative joint, the direction (each component -1 to +1) that will be applied per component on the vector, and a min and max vel in milimeter per second.  <a href="#gac77888b204d844c3db95128488615465">More...</a><br/></td></tr>
<tr class="separator:gac77888b204d844c3db95128488615465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3235bf8af638d81de1b26f9b57f639"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b3235bf8af638d81de1b26f9b57f639"></a>
FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>Fubi::addLinearMovementRecognizer</b> (SkeletonJoint::Joint joint, float dirX, float dirY, float dirZ, float minVel, float maxVel, float minLength, float maxLength=Fubi::Math::MaxFloat, Fubi::BodyMeasurement::Measurement measuringUnit=Fubi::BodyMeasurement::NUM_MEASUREMENTS, bool useLocalPositions=false, int atIndex=-1, const char *name=0, float maxAngleDifference=45.0f, bool useOnlyCorrectDirectionComponent=true, bool useFilteredData=false)</td></tr>
<tr class="separator:ga0b3235bf8af638d81de1b26f9b57f639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3275f751115eaa53d3a684418dfe58"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gabd3275f751115eaa53d3a684418dfe58">Fubi::addAngularMovementRecognizer</a> (Fubi::SkeletonJoint::Joint joint, float minVelX=-Fubi::Math::MaxFloat, float minVelY=-Fubi::Math::MaxFloat, float minVelZ=-Fubi::Math::MaxFloat, float maxVelX=Fubi::Math::MaxFloat, float maxVelY=Fubi::Math::MaxFloat, float maxVelZ=Fubi::Math::MaxFloat, bool useLocalOrients=true, int atIndex=-1, const char *name=0, float minConfidence=-1.0f, bool useFilteredData=false)</td></tr>
<tr class="memdesc:gabd3275f751115eaa53d3a684418dfe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined angular movement recognizer.  <a href="#gabd3275f751115eaa53d3a684418dfe58">More...</a><br/></td></tr>
<tr class="separator:gabd3275f751115eaa53d3a684418dfe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dac031a9bb9471513f5fbd915b8c702"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga4dac031a9bb9471513f5fbd915b8c702">Fubi::addLinearAccelerationRecognizer</a> (SkeletonJoint::Joint joint, float dirX, float dirY, float dirZ, float minAccel, float maxAccel=Fubi::Math::MaxFloat, int atIndex=-1, const char *name=0, float maxAngleDifference=45.0f, bool useOnlyCorrectDirectionComponent=true)</td></tr>
<tr class="memdesc:ga4dac031a9bb9471513f5fbd915b8c702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a user defined linear acceleration recognizer.  <a href="#ga4dac031a9bb9471513f5fbd915b8c702">More...</a><br/></td></tr>
<tr class="separator:ga4dac031a9bb9471513f5fbd915b8c702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91871c414a24af10bb51e65fbc674f52"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga91871c414a24af10bb51e65fbc674f52">Fubi::addCombinationRecognizer</a> (const char *xmlDefinition)</td></tr>
<tr class="memdesc:ga91871c414a24af10bb51e65fbc674f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a combination recognizer from a string that represents an xml node with the combination definition  <a href="#ga91871c414a24af10bb51e65fbc674f52">More...</a><br/></td></tr>
<tr class="separator:ga91871c414a24af10bb51e65fbc674f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47147be82e56a82496a943ded762a5b"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaf47147be82e56a82496a943ded762a5b">Fubi::loadRecognizersFromXML</a> (const char *fileName)</td></tr>
<tr class="memdesc:gaf47147be82e56a82496a943ded762a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a recognizer config xml file and adds the configured recognizers.  <a href="#gaf47147be82e56a82496a943ded762a5b">More...</a><br/></td></tr>
<tr class="separator:gaf47147be82e56a82496a943ded762a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441dc11397b2123fd6a93c39e93107fb"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga441dc11397b2123fd6a93c39e93107fb">Fubi::getNumUserDefinedRecognizers</a> ()</td></tr>
<tr class="memdesc:ga441dc11397b2123fd6a93c39e93107fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current number of user defined recognizers.  <a href="#ga441dc11397b2123fd6a93c39e93107fb">More...</a><br/></td></tr>
<tr class="separator:ga441dc11397b2123fd6a93c39e93107fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634002fda64712af356e48c2f6ad3297"><td class="memItemLeft" align="right" valign="top">FUBI_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga634002fda64712af356e48c2f6ad3297">Fubi::getUserDefinedRecognizerName</a> (unsigned int recognizerIndex)</td></tr>
<tr class="memdesc:ga634002fda64712af356e48c2f6ad3297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a user defined recognizer.  <a href="#ga634002fda64712af356e48c2f6ad3297">More...</a><br/></td></tr>
<tr class="separator:ga634002fda64712af356e48c2f6ad3297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e984c7ee22144b8033522dfa79bc0e"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga20e984c7ee22144b8033522dfa79bc0e">Fubi::getUserDefinedRecognizerIndex</a> (const char *recognizerName)</td></tr>
<tr class="memdesc:ga20e984c7ee22144b8033522dfa79bc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a user defined recognizer.  <a href="#ga20e984c7ee22144b8033522dfa79bc0e">More...</a><br/></td></tr>
<tr class="separator:ga20e984c7ee22144b8033522dfa79bc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa950145365c377bc32850ba01b38df71"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaa950145365c377bc32850ba01b38df71">Fubi::getUserDefinedCombinationRecognizerIndex</a> (const char *recognizerName)</td></tr>
<tr class="memdesc:gaa950145365c377bc32850ba01b38df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a user defined combination recognizer.  <a href="#gaa950145365c377bc32850ba01b38df71">More...</a><br/></td></tr>
<tr class="separator:gaa950145365c377bc32850ba01b38df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b87f6917bb3a7270e69fb89e6ba7e5"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga57b87f6917bb3a7270e69fb89e6ba7e5">Fubi::getNumUserDefinedCombinationRecognizers</a> ()</td></tr>
<tr class="memdesc:ga57b87f6917bb3a7270e69fb89e6ba7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current number of user defined combination recognizers.  <a href="#ga57b87f6917bb3a7270e69fb89e6ba7e5">More...</a><br/></td></tr>
<tr class="separator:ga57b87f6917bb3a7270e69fb89e6ba7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ec0ceb714c04eaa43c2fc12d65020f"><td class="memItemLeft" align="right" valign="top">FUBI_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gab1ec0ceb714c04eaa43c2fc12d65020f">Fubi::getUserDefinedCombinationRecognizerName</a> (unsigned int recognizerIndex)</td></tr>
<tr class="memdesc:gab1ec0ceb714c04eaa43c2fc12d65020f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a user defined combination recognizer.  <a href="#gab1ec0ceb714c04eaa43c2fc12d65020f">More...</a><br/></td></tr>
<tr class="separator:gab1ec0ceb714c04eaa43c2fc12d65020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91564b427870c0c6e2b74612c936b2c4"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga91564b427870c0c6e2b74612c936b2c4">Fubi::getCurrentUsers</a> (<a class="el" href="a00012.html">FubiUser</a> ***pUserContainer=0)</td></tr>
<tr class="memdesc:ga91564b427870c0c6e2b74612c936b2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all current users with their tracking information.  <a href="#ga91564b427870c0c6e2b74612c936b2c4">More...</a><br/></td></tr>
<tr class="separator:ga91564b427870c0c6e2b74612c936b2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e392f4ffccb8872502cd85005365abb"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00012.html">FubiUser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga3e392f4ffccb8872502cd85005365abb">Fubi::getUser</a> (unsigned int id)</td></tr>
<tr class="memdesc:ga3e392f4ffccb8872502cd85005365abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one user with his tracking information.  <a href="#ga3e392f4ffccb8872502cd85005365abb">More...</a><br/></td></tr>
<tr class="separator:ga3e392f4ffccb8872502cd85005365abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5bde2bfb6fedc665f5d474574802cd"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga6c5bde2bfb6fedc665f5d474574802cd">Fubi::getDepthResolution</a> (int &amp;width, int &amp;height)</td></tr>
<tr class="memdesc:ga6c5bde2bfb6fedc665f5d474574802cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current depth resolution or -1, -1 if failed.  <a href="#ga6c5bde2bfb6fedc665f5d474574802cd">More...</a><br/></td></tr>
<tr class="separator:ga6c5bde2bfb6fedc665f5d474574802cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6019b281270bcadd2dad4d53ee37104a"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga6019b281270bcadd2dad4d53ee37104a">Fubi::getRgbResolution</a> (int &amp;width, int &amp;height)</td></tr>
<tr class="memdesc:ga6019b281270bcadd2dad4d53ee37104a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current rgb resolution or -1, -1 if failed.  <a href="#ga6019b281270bcadd2dad4d53ee37104a">More...</a><br/></td></tr>
<tr class="separator:ga6019b281270bcadd2dad4d53ee37104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3888db1df751672a0adc84c12cb6d336"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga3888db1df751672a0adc84c12cb6d336">Fubi::getIRResolution</a> (int &amp;width, int &amp;height)</td></tr>
<tr class="memdesc:ga3888db1df751672a0adc84c12cb6d336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current ir resolution or -1, -1 if failed.  <a href="#ga3888db1df751672a0adc84c12cb6d336">More...</a><br/></td></tr>
<tr class="separator:ga3888db1df751672a0adc84c12cb6d336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b80b38af330aee5ed11f3c521138e56"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga9b80b38af330aee5ed11f3c521138e56">Fubi::getFingerCount</a> (unsigned int userID, bool leftHand=false, bool getMedianOfLastFrames=true, bool useOldConvexityDefectMethod=false)</td></tr>
<tr class="memdesc:ga9b80b38af330aee5ed11f3c521138e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shown fingers detected at the hand of one user (REQUIRES OPENCV!)  <a href="#ga9b80b38af330aee5ed11f3c521138e56">More...</a><br/></td></tr>
<tr class="separator:ga9b80b38af330aee5ed11f3c521138e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228e6b8570a66f48bede527de9a54fee"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga228e6b8570a66f48bede527de9a54fee">Fubi::enableFingerTracking</a> (unsigned int userID, bool leftHand, bool rightHand, bool useConvexityDefectMethod=false)</td></tr>
<tr class="memdesc:ga228e6b8570a66f48bede527de9a54fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables finger tracking for the hands of one user If enabled the finger count will be tracked over time and the median of these value will be returned in case of a query (REQUIRES OPENCV!)  <a href="#ga228e6b8570a66f48bede527de9a54fee">More...</a><br/></td></tr>
<tr class="separator:ga228e6b8570a66f48bede527de9a54fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191014773bdd26032eed94deb8812fd5"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga191014773bdd26032eed94deb8812fd5">Fubi::isUserInScene</a> (unsigned int userID)</td></tr>
<tr class="memdesc:ga191014773bdd26032eed94deb8812fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the user is currently seen in the depth image.  <a href="#ga191014773bdd26032eed94deb8812fd5">More...</a><br/></td></tr>
<tr class="separator:ga191014773bdd26032eed94deb8812fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b03ac13fe291c3af8f8520c5af62199"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga7b03ac13fe291c3af8f8520c5af62199">Fubi::isUserTracked</a> (unsigned int userID)</td></tr>
<tr class="memdesc:ga7b03ac13fe291c3af8f8520c5af62199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the user is currently tracked.  <a href="#ga7b03ac13fe291c3af8f8520c5af62199">More...</a><br/></td></tr>
<tr class="separator:ga7b03ac13fe291c3af8f8520c5af62199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20588f94621ed3116a4846ececf9651d"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00035.html">FubiUser::TrackingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga20588f94621ed3116a4846ececf9651d">Fubi::getCurrentTrackingData</a> (unsigned int userId, bool filteredData=false)</td></tr>
<tr class="memdesc:ga20588f94621ed3116a4846ececf9651d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the most current tracking info of the user (including all joint positions and orientations (local and global) and a timestamp)  <a href="#ga20588f94621ed3116a4846ececf9651d">More...</a><br/></td></tr>
<tr class="separator:ga20588f94621ed3116a4846ececf9651d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa579c340e00b6a7474f7c32c9957f4be"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00035.html">FubiUser::TrackingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaa579c340e00b6a7474f7c32c9957f4be">Fubi::getLastTrackingData</a> (unsigned int userId, bool filteredData=false)</td></tr>
<tr class="memdesc:gaa579c340e00b6a7474f7c32c9957f4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last tracking info of the user (one frame before the current one) (including all joint positions and orientations (local and global) and a timestamp)  <a href="#gaa579c340e00b6a7474f7c32c9957f4be">More...</a><br/></td></tr>
<tr class="separator:gaa579c340e00b6a7474f7c32c9957f4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67245098a7c8ecc865c25a9a2628ac82"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga67245098a7c8ecc865c25a9a2628ac82">Fubi::getSkeletonJointPosition</a> (<a class="el" href="a00035.html">FubiUser::TrackingData</a> *trackingInfo, SkeletonJoint::Joint joint, float &amp;x, float &amp;y, float &amp;z, float &amp;confidence, double &amp;timeStamp, bool localPosition=false)</td></tr>
<tr class="memdesc:ga67245098a7c8ecc865c25a9a2628ac82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the skeleton joint position out of the tracking info.  <a href="#ga67245098a7c8ecc865c25a9a2628ac82">More...</a><br/></td></tr>
<tr class="separator:ga67245098a7c8ecc865c25a9a2628ac82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b22ff3d35913a083ed6d04900cb23f0"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga6b22ff3d35913a083ed6d04900cb23f0">Fubi::getSkeletonJointOrientation</a> (<a class="el" href="a00035.html">FubiUser::TrackingData</a> *trackingInfo, SkeletonJoint::Joint joint, float *mat, float confidence, double &amp;timeStamp, bool localOrientation=true)</td></tr>
<tr class="memdesc:ga6b22ff3d35913a083ed6d04900cb23f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the skeleton joint orientation out of the tracking info.  <a href="#ga6b22ff3d35913a083ed6d04900cb23f0">More...</a><br/></td></tr>
<tr class="separator:ga6b22ff3d35913a083ed6d04900cb23f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd25a37aa474a0ee5e7bd02b10d16484"><td class="memItemLeft" align="right" valign="top">FUBI_API std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gacd25a37aa474a0ee5e7bd02b10d16484">Fubi::createTrackingDataVector</a> ()</td></tr>
<tr class="memdesc:gacd25a37aa474a0ee5e7bd02b10d16484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty vector of UserTrackinginfo structs.  <a href="#gacd25a37aa474a0ee5e7bd02b10d16484">More...</a><br/></td></tr>
<tr class="separator:gacd25a37aa474a0ee5e7bd02b10d16484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f0577998236d99ed4616d245ac6b48"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gab5f0577998236d99ed4616d245ac6b48">Fubi::releaseTrackingDataVector</a> (std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *vec)</td></tr>
<tr class="memdesc:gab5f0577998236d99ed4616d245ac6b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the formerly created vector.  <a href="#gab5f0577998236d99ed4616d245ac6b48">More...</a><br/></td></tr>
<tr class="separator:gab5f0577998236d99ed4616d245ac6b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d5b2315d989d4c71c28e178f6d1520"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga46d5b2315d989d4c71c28e178f6d1520">Fubi::getTrackingDataVectorSize</a> (std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *vec)</td></tr>
<tr class="memdesc:ga46d5b2315d989d4c71c28e178f6d1520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the vector.  <a href="#ga46d5b2315d989d4c71c28e178f6d1520">More...</a><br/></td></tr>
<tr class="separator:ga46d5b2315d989d4c71c28e178f6d1520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e600f406741feaa2ec95afbfe84221"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00035.html">FubiUser::TrackingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga33e600f406741feaa2ec95afbfe84221">Fubi::getTrackingData</a> (std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *vec, unsigned int index)</td></tr>
<tr class="memdesc:ga33e600f406741feaa2ec95afbfe84221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one element of the tracking info vector.  <a href="#ga33e600f406741feaa2ec95afbfe84221">More...</a><br/></td></tr>
<tr class="separator:ga33e600f406741feaa2ec95afbfe84221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab274c287e417c7e1148dae10f68661"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga5ab274c287e417c7e1148dae10f68661">Fubi::getClosestUserID</a> ()</td></tr>
<tr class="memdesc:ga5ab274c287e417c7e1148dae10f68661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OpenNI id of the user standing closest to the sensor (x-z plane)  <a href="#ga5ab274c287e417c7e1148dae10f68661">More...</a><br/></td></tr>
<tr class="separator:ga5ab274c287e417c7e1148dae10f68661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1417caa305f6fe1a63a35b64626293"><td class="memItemLeft" align="right" valign="top">FUBI_API std::deque&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga9a1417caa305f6fe1a63a35b64626293">Fubi::getClosestUserIDs</a> (int maxNumUsers=-1)</td></tr>
<tr class="memdesc:ga9a1417caa305f6fe1a63a35b64626293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ids of all users order by their distance to the sensor (x-z plane) Closest user is at the front, user with largest distance or untracked users at the back.  <a href="#ga9a1417caa305f6fe1a63a35b64626293">More...</a><br/></td></tr>
<tr class="separator:ga9a1417caa305f6fe1a63a35b64626293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccbdcafe946a4ad4fdb6ab37e4d9c53"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gafccbdcafe946a4ad4fdb6ab37e4d9c53">Fubi::getClosestUserIDs</a> (unsigned int *userIds, int maxNumUsers=-1)</td></tr>
<tr class="memdesc:gafccbdcafe946a4ad4fdb6ab37e4d9c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ids of all users order by their distance to the sensor (x-z plane) Closest user is at the front, user with largest distance or untracked users at the back.  <a href="#gafccbdcafe946a4ad4fdb6ab37e4d9c53">More...</a><br/></td></tr>
<tr class="separator:gafccbdcafe946a4ad4fdb6ab37e4d9c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeea215207ee95a52c071ddba2446b3f"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00012.html">FubiUser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gabeea215207ee95a52c071ddba2446b3f">Fubi::getClosestUser</a> ()</td></tr>
<tr class="memdesc:gabeea215207ee95a52c071ddba2446b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user standing closest to the sensor (x-z plane)  <a href="#gabeea215207ee95a52c071ddba2446b3f">More...</a><br/></td></tr>
<tr class="separator:gabeea215207ee95a52c071ddba2446b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814cfb3ee301f0ddea627cc4d7d8fb8a"><td class="memItemLeft" align="right" valign="top">FUBI_API std::deque&lt; <a class="el" href="a00012.html">FubiUser</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga814cfb3ee301f0ddea627cc4d7d8fb8a">Fubi::getClosestUsers</a> (int maxNumUsers=-1)</td></tr>
<tr class="memdesc:ga814cfb3ee301f0ddea627cc4d7d8fb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all users order by their distance to the sensor (x-z plane) Closest user is at the front, user with largest distance or untracked users at the back If maxNumUsers is given, the given number of closest users is additionally ordered from left to right position.  <a href="#ga814cfb3ee301f0ddea627cc4d7d8fb8a">More...</a><br/></td></tr>
<tr class="separator:ga814cfb3ee301f0ddea627cc4d7d8fb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13799687356f1db17755cb24c79eddd9"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga13799687356f1db17755cb24c79eddd9">Fubi::clearUserDefinedRecognizers</a> ()</td></tr>
<tr class="memdesc:ga13799687356f1db17755cb24c79eddd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops and removes all user defined recognizers.  <a href="#ga13799687356f1db17755cb24c79eddd9">More...</a><br/></td></tr>
<tr class="separator:ga13799687356f1db17755cb24c79eddd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425aafd817409bff0b6a4dba05d897ba"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga425aafd817409bff0b6a4dba05d897ba">Fubi::updateTrackingData</a> (unsigned int userId, <a class="el" href="a00032.html">Fubi::SkeletonJointPosition</a> *positions, double timeStamp=-1, <a class="el" href="a00031.html">Fubi::SkeletonJointOrientation</a> *orientations=0, <a class="el" href="a00030.html">Fubi::SkeletonJointAcceleration</a> *accelerations=0)</td></tr>
<tr class="memdesc:ga425aafd817409bff0b6a4dba05d897ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current tracking info of one user (including all joint positions. Optionally the orientations and a timestamp)  <a href="#ga425aafd817409bff0b6a4dba05d897ba">More...</a><br/></td></tr>
<tr class="separator:ga425aafd817409bff0b6a4dba05d897ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeab4817883aa7f0c76cacf73d1e561f"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gabeab4817883aa7f0c76cacf73d1e561f">Fubi::updateTrackingData</a> (unsigned int userId, float *skeleton, double timeStamp=-1, float *accelerations=0)</td></tr>
<tr class="memdesc:gabeab4817883aa7f0c76cacf73d1e561f"><td class="mdescLeft">&#160;</td><td class="mdescRight">same function as before, but skeleton and acceleartion as a plain float array  <a href="#gabeab4817883aa7f0c76cacf73d1e561f">More...</a><br/></td></tr>
<tr class="separator:gabeab4817883aa7f0c76cacf73d1e561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1f70097ed1bd7b1249fe4def6a4575"><td class="memItemLeft" align="right" valign="top">FUBI_API <a class="el" href="a00036.html">Fubi::Vec3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaee1f70097ed1bd7b1249fe4def6a4575">Fubi::realWorldToProjective</a> (const <a class="el" href="a00036.html">Fubi::Vec3f</a> &amp;realWorldVec, int xRes=640, int yRes=480, double hFOV=1.0144686707507438, double vFOV=0.78980943449644714)</td></tr>
<tr class="memdesc:gaee1f70097ed1bd7b1249fe4def6a4575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate from real world coordinates (milimeters) to screen coordinates (pixels in the depth/rgb/ir image). Uses the data of a present sensor, or alternatively calculates the projection according to given sensor values, or to standard values.  <a href="#gaee1f70097ed1bd7b1249fe4def6a4575">More...</a><br/></td></tr>
<tr class="separator:gaee1f70097ed1bd7b1249fe4def6a4575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2f395cd7a7dc60679fd33a0dfdf2d1"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga7d2f395cd7a7dc60679fd33a0dfdf2d1">Fubi::realWorldToProjective</a> (float realWorldX, float realWorldY, float realWorldZ, float &amp;screenX, float &amp;screenY, float &amp;screenZ, int xRes=640, int yRes=480, double hFOV=1.0144686707507438, double vFOV=0.78980943449644714)</td></tr>
<tr class="memdesc:ga7d2f395cd7a7dc60679fd33a0dfdf2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate from real world coordinates (milimeters) to screen coordinates (pixels in the depth/rgb/ir image). Uses the data of a present sensor, or alternatively calculates the projection according to given sensor values, or to standard values.  <a href="#ga7d2f395cd7a7dc60679fd33a0dfdf2d1">More...</a><br/></td></tr>
<tr class="separator:ga7d2f395cd7a7dc60679fd33a0dfdf2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bf978e749e70265c9fe8c3720fe5d5"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga53bf978e749e70265c9fe8c3720fe5d5">Fubi::resetTracking</a> ()</td></tr>
<tr class="memdesc:ga53bf978e749e70265c9fe8c3720fe5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">resests the tracking of all users  <a href="#ga53bf978e749e70265c9fe8c3720fe5d5">More...</a><br/></td></tr>
<tr class="separator:ga53bf978e749e70265c9fe8c3720fe5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876a3e5feec186357ff6dc1219681d52"><td class="memItemLeft" align="right" valign="top">FUBI_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga876a3e5feec186357ff6dc1219681d52">Fubi::getCurrentTime</a> ()</td></tr>
<tr class="memdesc:ga876a3e5feec186357ff6dc1219681d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">get time since program start in seconds  <a href="#ga876a3e5feec186357ff6dc1219681d52">More...</a><br/></td></tr>
<tr class="separator:ga876a3e5feec186357ff6dc1219681d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bcb8c2175b2e6b97d8346f0fab5302"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga08bcb8c2175b2e6b97d8346f0fab5302">Fubi::setFilterOptions</a> (float minCutOffFrequency=1.0f, float velocityCutOffFrequency=1.0f, float cutOffSlope=0.007f)</td></tr>
<tr class="memdesc:ga08bcb8c2175b2e6b97d8346f0fab5302"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the filtering options for smoothing the skeleton according to the 1 filter (still possible to get the unfiltered data)  <a href="#ga08bcb8c2175b2e6b97d8346f0fab5302">More...</a><br/></td></tr>
<tr class="separator:ga08bcb8c2175b2e6b97d8346f0fab5302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0c4dd71c2dfff1114bbd4b6ab7e8dc"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gabc0c4dd71c2dfff1114bbd4b6ab7e8dc">Fubi::getFilterOptions</a> (float &amp;minCutOffFrequency, float &amp;velocityCutOffFrequency, float &amp;cutOffSlope)</td></tr>
<tr class="memdesc:gabc0c4dd71c2dfff1114bbd4b6ab7e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the filtering options for smoothing the skeleton according to the 1 filter (still possible to get the unfiltered data)  <a href="#gabc0c4dd71c2dfff1114bbd4b6ab7e8dc">More...</a><br/></td></tr>
<tr class="separator:gabc0c4dd71c2dfff1114bbd4b6ab7e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac947568af8590849e93cc40920bfa355"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gac947568af8590849e93cc40920bfa355">Fubi::getCurrentCombinationRecognitionState</a> (const char *recognizerName, unsigned int userID, unsigned int &amp;numStates, bool &amp;isInterrupted, bool &amp;isInTransition)</td></tr>
<tr class="memdesc:gac947568af8590849e93cc40920bfa355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined combination recognizer for its current state.  <a href="#gac947568af8590849e93cc40920bfa355">More...</a><br/></td></tr>
<tr class="separator:gac947568af8590849e93cc40920bfa355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc877f5059df7b4876e63754489dd6d"><td class="memItemLeft" align="right" valign="top">FUBI_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga0dc877f5059df7b4876e63754489dd6d">Fubi::getCombinationRecognitionStateMetaInfo</a> (const char *recognizerName, unsigned int stateIndex, const char *propertyName)</td></tr>
<tr class="memdesc:ga0dc877f5059df7b4876e63754489dd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get meta information of a state of one recognizers.  <a href="#ga0dc877f5059df7b4876e63754489dd6d">More...</a><br/></td></tr>
<tr class="separator:ga0dc877f5059df7b4876e63754489dd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7046f49f3541639b3b4a54e8c7c222cf"><td class="memItemLeft" align="right" valign="top">FUBI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga7046f49f3541639b3b4a54e8c7c222cf">Fubi::initFingerSensor</a> (<a class="el" href="a00008.html#ae1e461c328e6b5085be4c952d478a7ee">Fubi::FingerSensorType::Type</a> type, float offsetPosX=0, float offsetPosY=-600.0f, float offsetPosZ=200.0f)</td></tr>
<tr class="memdesc:ga7046f49f3541639b3b4a54e8c7c222cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">initalizes a finger sensor such as the leap motion for tracking fingers  <a href="#ga7046f49f3541639b3b4a54e8c7c222cf">More...</a><br/></td></tr>
<tr class="separator:ga7046f49f3541639b3b4a54e8c7c222cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc26e60b890a0912890588cb4a9635e1"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gafc26e60b890a0912890588cb4a9635e1">Fubi::getAvailableFingerSensorTypes</a> ()</td></tr>
<tr class="memdesc:gafc26e60b890a0912890588cb4a9635e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently available finger sensor types (defined in <a class="el" href="a00040.html" title="a header file containing defines for configuring the Fubi build ">FubiConfig.h</a> before compilation)  <a href="#gafc26e60b890a0912890588cb4a9635e1">More...</a><br/></td></tr>
<tr class="separator:gafc26e60b890a0912890588cb4a9635e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5686049a5fd2a5c33f426f12fc011a"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
<a class="el" href="a00008.html#ae1e461c328e6b5085be4c952d478a7ee">Fubi::FingerSensorType::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaed5686049a5fd2a5c33f426f12fc011a">Fubi::getCurrentFingerSensorType</a> ()</td></tr>
<tr class="memdesc:gaed5686049a5fd2a5c33f426f12fc011a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the currently active sensor.  <a href="#gaed5686049a5fd2a5c33f426f12fc011a">More...</a><br/></td></tr>
<tr class="separator:gaed5686049a5fd2a5c33f426f12fc011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b79b4a72aa84122b5c42911796888c0"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga9b79b4a72aa84122b5c42911796888c0">Fubi::getNumHands</a> ()</td></tr>
<tr class="memdesc:ga9b79b4a72aa84122b5c42911796888c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently tracked hands.  <a href="#ga9b79b4a72aa84122b5c42911796888c0">More...</a><br/></td></tr>
<tr class="separator:ga9b79b4a72aa84122b5c42911796888c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac24ea386360e9e016faf1362f946c2"><td class="memItemLeft" align="right" valign="top">FUBI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga4ac24ea386360e9e016faf1362f946c2">Fubi::getHandID</a> (unsigned int index)</td></tr>
<tr class="memdesc:ga4ac24ea386360e9e016faf1362f946c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hand id from the user index.  <a href="#ga4ac24ea386360e9e016faf1362f946c2">More...</a><br/></td></tr>
<tr class="separator:ga4ac24ea386360e9e016faf1362f946c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e37bd5fd0a07c5441fd4becd3a9fca"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gac8e37bd5fd0a07c5441fd4becd3a9fca">Fubi::recognizeGestureOnHand</a> (const char *recognizerName, unsigned int handId)</td></tr>
<tr class="memdesc:gac8e37bd5fd0a07c5441fd4becd3a9fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined gesture or posture recognizer for its success.  <a href="#gac8e37bd5fd0a07c5441fd4becd3a9fca">More...</a><br/></td></tr>
<tr class="separator:gac8e37bd5fd0a07c5441fd4becd3a9fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5b1f126f84f50afe579983f8448016"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
Fubi::RecognitionResult::Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaee5b1f126f84f50afe579983f8448016">Fubi::getCombinationRecognitionProgressOnHand</a> (const char *recognizerName, unsigned int handId, std::vector&lt; <a class="el" href="a00009.html">FubiHand::FingerTrackingData</a> &gt; *handStates=0x0, bool restart=true, bool returnFilteredData=false, Fubi::RecognitionCorrectionHint *correctionHint=0x0)</td></tr>
<tr class="memdesc:gaee5b1f126f84f50afe579983f8448016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined combination recognizer for its progress.  <a href="#gaee5b1f126f84f50afe579983f8448016">More...</a><br/></td></tr>
<tr class="separator:gaee5b1f126f84f50afe579983f8448016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018413361603fd1fa846d9989fe58f8e"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga018413361603fd1fa846d9989fe58f8e">Fubi::enableCombinationRecognitionHand</a> (const char *combinationName, unsigned int handId, bool enable)</td></tr>
<tr class="memdesc:ga018413361603fd1fa846d9989fe58f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts or stops the recognition process of a user defined combination for one hand.  <a href="#ga018413361603fd1fa846d9989fe58f8e">More...</a><br/></td></tr>
<tr class="separator:ga018413361603fd1fa846d9989fe58f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef43f3531c29d8a9b93ad101ead024b8"><td class="memItemLeft" align="right" valign="top">FUBI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaef43f3531c29d8a9b93ad101ead024b8">Fubi::getCurrentCombinationRecognitionStateForHand</a> (const char *recognizerName, unsigned int handID, unsigned int &amp;numStates, bool &amp;isInterrupted, bool &amp;isInTransition)</td></tr>
<tr class="memdesc:gaef43f3531c29d8a9b93ad101ead024b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a user defined combination recognizer for its current state.  <a href="#gaef43f3531c29d8a9b93ad101ead024b8">More...</a><br/></td></tr>
<tr class="separator:gaef43f3531c29d8a9b93ad101ead024b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35b266a6e7f52c8672caeb35753cf62"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gab35b266a6e7f52c8672caeb35753cf62">Fubi::getFingerSensorOffsetPosition</a> (float &amp;xOffset, float &amp;yOffset, float &amp;zOffset)</td></tr>
<tr class="memdesc:gab35b266a6e7f52c8672caeb35753cf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset position of the current finger sensor to the main sensor.  <a href="#gab35b266a6e7f52c8672caeb35753cf62">More...</a><br/></td></tr>
<tr class="separator:gab35b266a6e7f52c8672caeb35753cf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea0cad63c3d9f92699370c44a2c5b5dd"><td class="memItemLeft" align="right" valign="top">FUBI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaea0cad63c3d9f92699370c44a2c5b5dd">Fubi::setFingerSensorOffsetPosition</a> (float xOffset, float yOffset, float zOffset)</td></tr>
<tr class="memdesc:gaea0cad63c3d9f92699370c44a2c5b5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset position of the current finger sensor to the main sensor.  <a href="#gaea0cad63c3d9f92699370c44a2c5b5dd">More...</a><br/></td></tr>
<tr class="separator:gaea0cad63c3d9f92699370c44a2c5b5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf83ba1fdeaedc8f35d1cec740b88ab4f"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
<a class="el" href="a00024.html#a6f8ea6ba5cf047ff0fbe83b76cb70a86">Fubi::RecognizerTarget::Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#gaf83ba1fdeaedc8f35d1cec740b88ab4f">Fubi::getCombinationRecognizerTargetSensor</a> (const char *recognizerName)</td></tr>
<tr class="memdesc:gaf83ba1fdeaedc8f35d1cec740b88ab4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target sensor of a user defined combination recognizer.  <a href="#gaf83ba1fdeaedc8f35d1cec740b88ab4f">More...</a><br/></td></tr>
<tr class="separator:gaf83ba1fdeaedc8f35d1cec740b88ab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876a93a4cb0174a59c7dedc7e10a2336"><td class="memItemLeft" align="right" valign="top">FUBI_API <br class="typebreak"/>
<a class="el" href="a00024.html#a6f8ea6ba5cf047ff0fbe83b76cb70a86">Fubi::RecognizerTarget::Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#ga876a93a4cb0174a59c7dedc7e10a2336">Fubi::getRecognizerTargetSensor</a> (const char *recognizerName)</td></tr>
<tr class="memdesc:ga876a93a4cb0174a59c7dedc7e10a2336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target sensor for a recognizer.  <a href="#ga876a93a4cb0174a59c7dedc7e10a2336">More...</a><br/></td></tr>
<tr class="separator:ga876a93a4cb0174a59c7dedc7e10a2336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>All the C++ API functions </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae213ab15ce900f6b9306b6fd8fa8ec16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>openniXmlconfig</em> = <code>0x0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3">Fubi::SkeletonTrackingProfile::Profile</a>&#160;</td>
          <td class="paramname"><em>profile</em> = <code><a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3a7f53042d38ba34fa228a2b6c684984a5">Fubi::SkeletonTrackingProfile::ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterMinCutOffFrequency</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterVelocityCutOffFrequency</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterCutOffSlope</em> = <code>0.007f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mirrorStreams</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>registerStreams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> with OpenN 1.x using the given xml file and sets the skeleton profile. If no xml file is given, <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> will be intialized without OpenNI tracking enabled &ndash;&gt; methods that need an openni context won't work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openniXmlconfig</td><td>name of the xml file for OpenNI 1.x initialization inlcuding all needed productions nodes (should be placed in the working directory, i.e. "bin" folder) if config == 0x0, then OpenNI won't be initialized and <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> stays in non-tracking mode </td></tr>
    <tr><td class="paramname">profile</td><td>set the openNI skeleton profile </td></tr>
    <tr><td class="paramname">filterMinCutOffFrequency,filterVelocityCutOffFrequency,filterCutOffSlope</td><td>options for filtering the tracking data if wanted </td></tr>
    <tr><td class="paramname">mirrorStreams</td><td>whether the stream should be mirrored or not </td></tr>
    <tr><td class="paramname">registerStreams</td><td>whether the depth stream should be registered to the color stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully initialized or already initialized before, false means bad xml file or other serious problem with OpenNI initialization </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2cf0e80e814ff42a8bb1d72faa63624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::init </td>
          <td>(</td>
          <td class="paramtype">const SensorOptions &amp;&#160;</td>
          <td class="paramname"><em>sensorOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterOptions &amp;&#160;</td>
          <td class="paramname"><em>filterOptions</em> = <code>FilterOptions()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> with an options file for the sensor init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorOptions</td><td>configuration for the sensor </td></tr>
    <tr><td class="paramname">filterOptions</td><td>filter options for additionally filtering of the tracking data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully initialized or already initialized before, false means problem with sensor init </dd></dl>

</div>
</div>
<a class="anchor" id="gaff24edb1c70ec72965812578c9a33cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depthWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depthHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depthFPS</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgbWidth</em> = <code>640</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgbHeight</em> = <code>480</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgbFPS</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irWidth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irHeight</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irFPS</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921e">Fubi::SensorType::Type</a>&#160;</td>
          <td class="paramname"><em>sensorType</em> = <code><a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921eabd46c2311df377fae2ae9c3994365fe5">Fubi::SensorType::OPENNI2</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3">Fubi::SkeletonTrackingProfile::Profile</a>&#160;</td>
          <td class="paramname"><em>profile</em> = <code><a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3a7f53042d38ba34fa228a2b6c684984a5">Fubi::SkeletonTrackingProfile::ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterMinCutOffFrequency</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterVelocityCutOffFrequency</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>filterCutOffSlope</em> = <code>0.007f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mirrorStream</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>registerStreams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a> with specific options for the sensor init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthWidth,depthHeight,depthFPS,rgbWidth,rgbHeight,rgbFPS,irWidth,irHeight,irFPS,sensorType,profile,filterMinCutOffFrequency,filterVelocityCutOffFrequency,filterCutOffSlope,mirrorStream,registerStreams</td><td>configuration for the sensor as in the <a class="el" href="a00026.html" title="Options for a sensor, including which streams to use, tracking options and global options for all str...">SensorOptions</a> and <a class="el" href="a00006.html" title="Parameters for configuring the filtering of joint tracking data. ">FilterOptions</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succesfully initialized or already initialized before, false means problem with sensor init </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bcb55d542e517d4aa5e105f93e1421c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::switchSensor </td>
          <td>(</td>
          <td class="paramtype">const SensorOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to switch between different sensor types during runtime Note that this will also reinitialize most parts of <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>options for initializing the new sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sensor has been succesfully initialized </dd></dl>

</div>
</div>
<a class="anchor" id="ga28ecfd12445e1749668d5ec4e8616015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::switchSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921e">Fubi::SensorType::Type</a>&#160;</td>
          <td class="paramname"><em>sensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depthWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depthHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depthFPS</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgbWidth</em> = <code>640</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgbHeight</em> = <code>480</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgbFPS</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irWidth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irHeight</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irFPS</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3">Fubi::SkeletonTrackingProfile::Profile</a>&#160;</td>
          <td class="paramname"><em>profile</em> = <code><a class="el" href="a00033.html#a0d43e32c8d2e96b300d9307bb90c73c3a7f53042d38ba34fa228a2b6c684984a5">Fubi::SkeletonTrackingProfile::ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mirrorStream</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>registerStreams</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to switch between different sensor types during runtime Note that this will also reinitialize most parts of <a class="el" href="a00046.html" title="The Fubi namespace provides all methods to control the Full Body Interaction framework (FUBI)...">Fubi</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorType</td><td>the sensor type to switch to </td></tr>
    <tr><td class="paramname">sensorType,depthWidth,depthHeight,depthFPS,rgbWidth,rgbHeight,rgbFPS,irWidth,irHeight,irFPS,profile,mirrorStream,registerStreams</td><td>configuration for the sensor as in the <a class="el" href="a00026.html" title="Options for a sensor, including which streams to use, tracking options and global options for all str...">SensorOptions</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sensor has been succesfully initialized </dd></dl>

</div>
</div>
<a class="anchor" id="gaab2a97d9834d1921bcca827633ed7071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getAvailableSensorTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently available sensor types (defined in <a class="el" href="a00040.html" title="a header file containing defines for configuring the Fubi build ">FubiConfig.h</a> before compilation) </p>
<dl class="section return"><dt>Returns</dt><dd>an int composed of the currently available sensor types (see <a class="el" href="a00027.html" title="All supported body tracking sensor types, need to be enabled in the FubiConfig.h Further installation...">SensorType</a> enum for the meaning) </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e3a6930abb4fec54c139fb5c0502856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00027.html#a94373f592e8d027478b3d9736961921e">Fubi::SensorType::Type</a> Fubi::getCurrentSensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the currently active sensor. </p>
<dl class="section return"><dt>Returns</dt><dd>the current sensor type </dd></dl>

</div>
</div>
<a class="anchor" id="gaa422b77cda7f191b315b061e7a997409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuts down OpenNI and the tracker, releasing all allocated memory. </p>

</div>
</div>
<a class="anchor" id="gad7e26bd58ab074f4e01bfd211d1d65af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if OpenNI has been already initialized. </p>

</div>
</div>
<a class="anchor" id="gaeb391d7b7f9fceb7b2d3c421a5d70de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::updateSensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the sensor to get the next frame of depth, rgb, and tracking data. Also searches for users in the scene and loads the default tracking calibration for new users or request a calibration. </p>

</div>
</div>
<a class="anchor" id="gaec29fdfbe5e3e592f1cdbbb752292ef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::getImage </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>outputImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageType::Type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageNumChannels::Channel&#160;</td>
          <td class="paramname"><em>numChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageDepth::Depth&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>renderOptions</em> = <code>(RenderOptions::Shapes|RenderOptions::Skeletons|RenderOptions::UserCaptions)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jointsToRender</em> = <code>RenderOptions::ALL_JOINTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DepthImageModification::Modification&#160;</td>
          <td class="paramname"><em>depthModifications</em> = <code>DepthImageModification::UseHistogram</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fubi::SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>jointOfInterest</em> = <code>Fubi::SkeletonJoint::NUM_JOINTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moveCroppedToUpperLeft</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve an image from one of the OpenNI production nodes with specific format and optionally enhanced by different tracking information Some render options require an OpenCV installation! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputImage</td><td>[out] pointer to a unsigned char array Will be filled with wanted image Array has to be of correct size, e.g. depth image (640x480 std resolution) with tracking info requires 4 channels (RGBA) &ndash;&gt; size = 640*480*4 = 1228800 </td></tr>
    <tr><td class="paramname">type</td><td>can be color, depth, or ir image </td></tr>
    <tr><td class="paramname">numChannels</td><td>number channels in the image 1, 3 or 4 </td></tr>
    <tr><td class="paramname">depth</td><td>the pixel depth of the image, 8 bit (standard) or 16 bit (mainly usefull for depth images </td></tr>
    <tr><td class="paramname">renderOptions</td><td>options for rendering additional informations into the image (e.g. tracking skeleton) or swapping the r and b channel </td></tr>
    <tr><td class="paramname">jointsToRender</td><td>defines for which of the joints the trackinginfo (see renderOptions) should be rendererd </td></tr>
    <tr><td class="paramname">depthModifications</td><td>options for transforming the depth image to a more visible format </td></tr>
    <tr><td class="paramname">userId</td><td>If set to something else than 0 an image will be cut cropped around (the joint of interest of) this user, if 0 the whole image is put out. </td></tr>
    <tr><td class="paramname">jointOfInterest</td><td>the joint of the user the image is cropped around and a threshold on the depth values is applied. If set to num_joints fubi tries to crop out the whole user. </td></tr>
    <tr><td class="paramname">moveCroppedToUpperLeft</td><td>moves the cropped image to the upper left corner </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2cab8087177c391cdb87302914ea478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::saveImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jpegQuality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageType::Type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageNumChannels::Channel&#160;</td>
          <td class="paramname"><em>numChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageDepth::Depth&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>renderOptions</em> = <code>(RenderOptions::Shapes|RenderOptions::Skeletons|RenderOptions::UserCaptions)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jointsToRender</em> = <code>RenderOptions::ALL_JOINTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DepthImageModification::Modification&#160;</td>
          <td class="paramname"><em>depthModifications</em> = <code>DepthImageModification::UseHistogram</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fubi::SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>jointOfInterest</em> = <code>Fubi::SkeletonJoint::NUM_JOINTS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save an image from one of the OpenNI production nodes with specific format and optionally enhanced by different tracking information </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>filename where the image should be saved to can be relative to the working directory (bin folder) or absolute the file extension determins the file format (should be jpg) </td></tr>
    <tr><td class="paramname">jpegQuality</td><td>qualitiy (= 88) of the jpeg compression if a jpg file is requested, ranges from 0 to 100 (best quality) </td></tr>
    <tr><td class="paramname">type</td><td>can be color, depth, or ir image </td></tr>
    <tr><td class="paramname">numChannels</td><td>number channels in the image 1, 3 or 4 </td></tr>
    <tr><td class="paramname">depth</td><td>the pixel depth of the image, 8 bit (standard) or 16 bit (mainly usefull for depth images </td></tr>
    <tr><td class="paramname">renderOptions</td><td>options for rendering additional informations into the image (e.g. tracking skeleton) or swapping the r and b channel </td></tr>
    <tr><td class="paramname">jointsToRender</td><td>defines for which of the joints the trackinginfo (see renderOptions) should be rendererd </td></tr>
    <tr><td class="paramname">depthModifications</td><td>options for transforming the depht image to a more visible format </td></tr>
    <tr><td class="paramname">userId</td><td>If set to something else than 0 an image will be cut cropped around (the joint of interest of) this user, if 0 the whole image is put out. </td></tr>
    <tr><td class="paramname">jointOfInterest</td><td>the joint of the user the image is cropped around and a threshold on the depth values is applied. If set to num_joints fubi tries to crop out the whole user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5631a7559e0abb1ff68ffbb98b11ccf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::recognizeGestureOn </td>
          <td>(</td>
          <td class="paramtype">Postures::Posture&#160;</td>
          <td class="paramname"><em>postureID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to recognize a posture in the current frame of tracking data of one user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">postureID</td><td>enum id of the posture to be found in <a class="el" href="a00043.html" title="a header file containing the ids and names of all postures and combinations predefined in code ...">FubiPredefinedGestures.h</a> </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="ga2994bb1130c06498be9bee9a274aefb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::recognizeGestureOn </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>recognizerIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *&#160;</td>
          <td class="paramname"><em>correctionHint</em> = <code>0x0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined gesture or posture recognizer for its success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerIndex</td><td>id of the recognizer return during its creation </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user to be checked </td></tr>
    <tr><td class="paramname">correctionHint</td><td>[out] will contain information about why the recognition failed if wanted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="ga1254f7661042229bb7a7d629ba91fdf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::recognizeGestureOn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *&#160;</td>
          <td class="paramname"><em>correctionHint</em> = <code>0x0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined gesture or posture recognizer for its success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the recognizer return during its creation </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user to be checked </td></tr>
    <tr><td class="paramname">correctionHint</td><td>[out] will contain information about why the recognition failed if wanted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fdb51f689c1c86a3c3eeb9fe71c73ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::getCombinationRecognitionProgressOn </td>
          <td>(</td>
          <td class="paramtype">Combinations::Combination&#160;</td>
          <td class="paramname"><em>combinationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *&#160;</td>
          <td class="paramname"><em>userStates</em> = <code>0x0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnFilteredData</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *&#160;</td>
          <td class="paramname"><em>correctionHint</em> = <code>0x0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a combination recognizer for its progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">combinationID</td><td>enum id of the combination to be found in <a class="el" href="a00043.html" title="a header file containing the ids and names of all postures and combinations predefined in code ...">FubiPredefinedGestures.h</a> </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user to be checked </td></tr>
    <tr><td class="paramname">userStates</td><td>(= 0x0) pointer to a vector of tracking data that represents the tracking information of the user during the recognition of each state </td></tr>
    <tr><td class="paramname">restart</td><td>(=true) if set to true, the recognizer automatically restarts, so the combination can be recognized again. </td></tr>
    <tr><td class="paramname">returnFilteredData</td><td>if true, the user states vector will contain filtered data </td></tr>
    <tr><td class="paramname">correctionHint</td><td>[out] on NOT_RECOGNIZED, this struct will contain information about why the recognition failed if wanted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="ga56edfa3727aa96bfc56e264f5f2ec58a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::getCombinationRecognitionProgressOn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *&#160;</td>
          <td class="paramname"><em>userStates</em> = <code>0x0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnFilteredData</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *&#160;</td>
          <td class="paramname"><em>correctionHint</em> = <code>0x0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined combination recognizer for its progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the combination </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user to be checked </td></tr>
    <tr><td class="paramname">userStates</td><td>(= 0x0) pointer to a vector of tracking data that represents the tracking information of the user during the recognition of each state </td></tr>
    <tr><td class="paramname">restart</td><td>(=true) if set to true, the recognizer automatically restarts, so the combination can be recognized again. </td></tr>
    <tr><td class="paramname">returnFilteredData</td><td>if true, the user states vector will contain filtered data </td></tr>
    <tr><td class="paramname">correctionHint</td><td>[out] on NOT_RECOGNIZED, this struct will contain information about why the recognition failed if wanted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf24b874ac9061d1e022e1a5eb803429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::enableCombinationRecognition </td>
          <td>(</td>
          <td class="paramtype">Combinations::Combination&#160;</td>
          <td class="paramname"><em>combinationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts or stops the recognition process of a combination for one user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">combinationID</td><td>enum id of the combination to be found in <a class="el" href="a00043.html" title="a header file containing the ids and names of all postures and combinations predefined in code ...">FubiPredefinedGestures.h</a> or Combinations::NUM_COMBINATIONS for all combinations </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user for whom the recognizers should be modified </td></tr>
    <tr><td class="paramname">enable</td><td>if set to true, the recognizer will be started (if not already stared), else it stops </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga92918d879eb3111178cd04f05b39f7a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::enableCombinationRecognition </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>combinationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts or stops the recognition process of a user defined combination for one user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">combinationName</td><td>name defined for this recognizer </td></tr>
    <tr><td class="paramname">userID</td><td>the id of the user for whom the recognizers should be modified </td></tr>
    <tr><td class="paramname">enable</td><td>if set to true, the recognizer will be started (if not already stared), else it stops </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89012c22cf6b53abc71f7ce0a4f6911b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::setAutoStartCombinationRecognition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combinations::Combination&#160;</td>
          <td class="paramname"><em>combinationID</em> = <code>Combinations::NUM_COMBINATIONS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically starts combination recogntion for new users. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>if set to true, the recognizer will automatically start for new users, else this must be done manually (by using enableCombinationRecognition(..)) </td></tr>
    <tr><td class="paramname">combinationID</td><td>enum id of the combination to be found in <a class="el" href="a00043.html" title="a header file containing the ids and names of all postures and combinations predefined in code ...">FubiPredefinedGestures.h</a> or Combinations::NUM_COMBINATIONS for all combinations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf05e1acf8f3abce0225ab7dae712f37d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::getAutoStartCombinationRecognition </td>
          <td>(</td>
          <td class="paramtype">Combinations::Combination&#160;</td>
          <td class="paramname"><em>combinationID</em> = <code>Combinations::NUM_COMBINATIONS</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if autostart is activated for a combination recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">combinationID</td><td>enum id of the combination to be found in <a class="el" href="a00043.html" title="a header file containing the ids and names of all postures and combinations predefined in code ...">FubiPredefinedGestures.h</a> orCombinations::NUM_COMBINATIONS for all combinations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the corresponding auto start is activated </dd></dl>

</div>
</div>
<a class="anchor" id="ga6825ee1823b821489ef8273c8d3b0010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getColorForUserID </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the color for a user in the background image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>OpennNI user id of the user of interest </td></tr>
    <tr><td class="paramname">r,g,b</td><td>[out] returns the red, green, and blue components of the color in which the users shape is displayed in the tracking image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadcb2308cb44ebc2930c55643ca29a8bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getUserID </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns user id from the user index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the user in the user array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of that user or 0 if not found </dd></dl>

</div>
</div>
<a class="anchor" id="ga43737fba1941a25879985a8b0b054c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addJointRelationRecognizer </td>
          <td>(</td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>relJoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minX</em> = <code>-Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minY</em> = <code>-Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minZ</em> = <code>-Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxX</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxY</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxZ</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minDistance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistance</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalPositions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minConfidence</em> = <code>-1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fubi::BodyMeasurement::Measurement&#160;</td>
          <td class="paramname"><em>measuringUnit</em> = <code>Fubi::BodyMeasurement::NUM_MEASUREMENTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined joint relation recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">relJoint</td><td>the joint in which it has to be in a specific relation </td></tr>
    <tr><td class="paramname">minX,minY,minZ</td><td>(=-inf, -inf, -inf) the minimal values allowed for the vectore relJoint -&gt; joint </td></tr>
    <tr><td class="paramname">maxX,maxY,maxZ</td><td>(=inf, inf, inf) the maximal values allowed for the vectore relJoint -&gt; joint </td></tr>
    <tr><td class="paramname">minDistance</td><td>(= 0) the minimal distance between joint and relJoint </td></tr>
    <tr><td class="paramname">maxDistance</td><td>(= inf) the maximal distance between joint and relJoint </td></tr>
    <tr><td class="paramname">useLocalPositions</td><td>use positions in the local coordinate system of the user based on the torso transformation </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>(= 0) sets a name for the recognizer (should be unique!) </td></tr>
    <tr><td class="paramname">minConfidence</td><td>(=-1) if given this is the mimimum confidence required from tracking for the recognition to be succesful </td></tr>
    <tr><td class="paramname">measuringUnit</td><td>the measuring unit for the values (millimeter by default) </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="ga46cc6f574195ac649fac5998f1ac4854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addJointOrientationRecognizer </td>
          <td>(</td>
          <td class="paramtype">Fubi::SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minX</em> = <code>-180.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minY</em> = <code>-180.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minZ</em> = <code>-180.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxX</em> = <code>180.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxY</em> = <code>180.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxZ</em> = <code>180.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalOrientations</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minConfidence</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined joint orientation recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">minX,minY,minZ</td><td>(=-180, -180, -180) the minimal degrees allowed for the joint orientation </td></tr>
    <tr><td class="paramname">maxX,maxY,maxZ</td><td>(=180, 180, 180) the maximal degrees allowed for the joint orientation </td></tr>
    <tr><td class="paramname">useLocalOrientations</td><td>if true, uses a local orienation in which the parent orientation has been substracted </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>(= 0) sets a name for the recognizer (should be unique!) </td></tr>
    <tr><td class="paramname">minConfidence</td><td>(=-1) if given this is the mimimum confidence required from tracking for the recognition to be succesful </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="gadb3ced0dc57ca4a4b17d78a064abca76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addJointOrientationRecognizer </td>
          <td>(</td>
          <td class="paramtype">Fubi::SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>orientX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>orientY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>orientZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAngleDifference</em> = <code>45.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalOrientations</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minConfidence</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined joint orientation recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">orientX,orientY,orientZ</td><td>indicate the wanted joint orientation </td></tr>
    <tr><td class="paramname">maxAngleDifference</td><td>(=45) the maximum angle difference that is allowed between the requested orientation and the actual orientation </td></tr>
    <tr><td class="paramname">useLocalOrientations</td><td>if true, uses a local orienation in which the parent orientation has been substracted </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>(= 0) sets a name for the recognizer (should be unique!) </td></tr>
    <tr><td class="paramname">minConfidence</td><td>(=-1) if given this is the mimimum confidence required from tracking for the recognition to be succesful </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3a2707828a308832cf62c4d9f277683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addFingerCountRecognizer </td>
          <td>(</td>
          <td class="paramtype">Fubi::SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>handJoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minFingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxFingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minConfidence</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useMedianCalculation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined finger count recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handJoint</td><td>the hand joint of interest </td></tr>
    <tr><td class="paramname">minFingers</td><td>the minimum number of fingers the user should show up </td></tr>
    <tr><td class="paramname">maxFingers</td><td>the maximum number of fingers the user should show up </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>(= 0) sets a name for the recognizer (should be unique!) </td></tr>
    <tr><td class="paramname">minConfidence</td><td>(=-1) if given this is the mimimum confidence required from tracking for the recognition to be succesful </td></tr>
    <tr><td class="paramname">useMedianCalculation</td><td>(=false) if true, the median for the finger count will be calculated over several frames instead of always taking the current detection </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="gafcf1289a004219995363502680bef410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addLinearMovementRecognizer </td>
          <td>(</td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>relJoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxVel</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalPositions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAngleDifference</em> = <code>45.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOnlyCorrectDirectionComponent</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined linear movement recognizer A linear gesture has a vector calculated as joint - relative joint, the direction (each component -1 to +1) that will be applied per component on the vector, and a min and max vel in milimeter per second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">relJoint</td><td>the joint in which it has to be in a specifc relation </td></tr>
    <tr><td class="paramname">dirX,dirY,dirZ</td><td>the direction in which the movement should happen </td></tr>
    <tr><td class="paramname">minVel</td><td>the minimal velocity that has to be reached in this direction </td></tr>
    <tr><td class="paramname">maxVel</td><td>(= inf) the maximal velocity that is allowed in this direction </td></tr>
    <tr><td class="paramname">useLocalPositions</td><td>use positions in the local coordinate system of the user based on the torso transformation </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>name of the recognizer </td></tr>
    <tr><td class="paramname">maxAngleDifference</td><td>(=45) the maximum angle difference that is allowed between the requested direction and the actual movement direction </td></tr>
    <tr><td class="paramname">useOnlyCorrectDirectionComponent</td><td>(=true) If true, this only takes the component of the actual movement that is conform the requested direction, else it always uses the actual movement for speed calculation </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="gac77888b204d844c3db95128488615465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addLinearMovementRecognizer </td>
          <td>(</td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>relJoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fubi::BodyMeasurement::Measurement&#160;</td>
          <td class="paramname"><em>measuringUnit</em> = <code>Fubi::BodyMeasurement::NUM_MEASUREMENTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalPositions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAngleDifference</em> = <code>45.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOnlyCorrectDirectionComponent</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined linear movement recognizer A linear gesture has a vector calculated as joint - relative joint, the direction (each component -1 to +1) that will be applied per component on the vector, and a min and max vel in milimeter per second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">relJoint</td><td>the joint in which it has to be in a specifc relation </td></tr>
    <tr><td class="paramname">dirX,dirY,dirZ</td><td>the direction in which the movement should happen </td></tr>
    <tr><td class="paramname">minVel</td><td>the minimal velocity that has to be reached in this direction </td></tr>
    <tr><td class="paramname">maxVel</td><td>(= inf) the maximal velocity that is allowed in this direction </td></tr>
    <tr><td class="paramname">minLength</td><td>the minimal length of path that has to be reached (only works within a combination rec) </td></tr>
    <tr><td class="paramname">maxLength</td><td>the maximal length of path that can be reached (only works within a combination rec) </td></tr>
    <tr><td class="paramname">measuringUnit</td><td>measuring unit for the path length </td></tr>
    <tr><td class="paramname">useLocalPositions</td><td>use positions in the local coordinate system of the user based on the torso transformation </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>name of the recognizer </td></tr>
    <tr><td class="paramname">maxAngleDifference</td><td>(=45) the maximum angle difference that is allowed between the requested direction and the actual movement direction </td></tr>
    <tr><td class="paramname">useOnlyCorrectDirectionComponent</td><td>(=true) If true, this only takes the component of the actual movement that is conform the requested direction, else it always uses the actual movement for speed calculation </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="gabd3275f751115eaa53d3a684418dfe58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addAngularMovementRecognizer </td>
          <td>(</td>
          <td class="paramtype">Fubi::SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minVelX</em> = <code>-Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minVelY</em> = <code>-Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minVelZ</em> = <code>-Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxVelX</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxVelY</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxVelZ</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalOrients</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minConfidence</em> = <code>-1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFilteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined angular movement recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">minVelX,minVelY,minVelZ</td><td>the minimum angular velocity per axis (also defines the rotation direction) </td></tr>
    <tr><td class="paramname">maxVelX,maxVelY,maxVelZ</td><td>the maximum angular velocity per axis (also defines the rotation direction) </td></tr>
    <tr><td class="paramname">useLocalOrients</td><td>whether local ("substracted" parent orientation = the actual joint orientation, not the orientation in space) or global orientations should be used </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>name of the recognizer </td></tr>
    <tr><td class="paramname">minConfidence</td><td>(=-1) if given this is the mimimum confidence required from tracking for the recognition to be succesful </td></tr>
    <tr><td class="paramname">useFilteredData</td><td>(=false) if true, the recognizer will use the filtered tracking data instead of the raw one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dac031a9bb9471513f5fbd915b8c702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::addLinearAccelerationRecognizer </td>
          <td>(</td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dirZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAccel</em> = <code>Fubi::Math::MaxFloat</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxAngleDifference</em> = <code>45.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOnlyCorrectDirectionComponent</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a user defined linear acceleration recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint</td><td>the joint of interest </td></tr>
    <tr><td class="paramname">dirX,dirY,dirZ</td><td>the direction in which the movement should happen </td></tr>
    <tr><td class="paramname">minAccel</td><td>the minimal acceleration that has to be reached in this direction </td></tr>
    <tr><td class="paramname">maxAccel</td><td>(= inf) the maximal acceleration that is allowed in this direction </td></tr>
    <tr><td class="paramname">atIndex</td><td>(= -1) if an index is given, the corresponding recognizer will be replaced instead of creating a new one </td></tr>
    <tr><td class="paramname">name</td><td>name of the recognizer </td></tr>
    <tr><td class="paramname">maxAngleDifference</td><td>(=45) the maximum angle difference that is allowed between the requested direction and the actual movement direction </td></tr>
    <tr><td class="paramname">useOnlyCorrectDirectionComponent</td><td>(=true) If true, this only takes the component of the actual movement that is conform the requested direction, else it always uses the actual movement for speed calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the recognizer needed to call it later </dd></dl>

</div>
</div>
<a class="anchor" id="ga91871c414a24af10bb51e65fbc674f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::addCombinationRecognizer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xmlDefinition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a combination recognizer from a string that represents an xml node with the combination definition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmlDefinition</td><td>string containing the xml definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the combination was loaded succesfully </dd></dl>

</div>
</div>
<a class="anchor" id="gaf47147be82e56a82496a943ded762a5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::loadRecognizersFromXML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a recognizer config xml file and adds the configured recognizers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>name of the xml config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one recognizers was loaded from the given xml </dd></dl>

</div>
</div>
<a class="anchor" id="ga441dc11397b2123fd6a93c39e93107fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getNumUserDefinedRecognizers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current number of user defined recognizers. </p>
<dl class="section return"><dt>Returns</dt><dd>number of recognizers, the recognizers also have the indices 0 to numberOfRecs-1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga634002fda64712af356e48c2f6ad3297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API const char* Fubi::getUserDefinedRecognizerName </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>recognizerIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a user defined recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerIndex</td><td>index of the recognizer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the recognizer name or an empty string if the user is not found or the name not set </dd></dl>

</div>
</div>
<a class="anchor" id="ga20e984c7ee22144b8033522dfa79bc0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getUserDefinedRecognizerIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of a user defined recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the recognizer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the recognizer name or -1 if not found </dd></dl>

</div>
</div>
<a class="anchor" id="gaa950145365c377bc32850ba01b38df71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getUserDefinedCombinationRecognizerIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of a user defined combination recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the recognizer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the recognizer name or -1 if not found </dd></dl>

</div>
</div>
<a class="anchor" id="ga57b87f6917bb3a7270e69fb89e6ba7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getNumUserDefinedCombinationRecognizers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current number of user defined combination recognizers. </p>
<dl class="section return"><dt>Returns</dt><dd>number of recognizers, the recognizers also have the indices 0 to numberOfRecs-1 </dd></dl>

</div>
</div>
<a class="anchor" id="gab1ec0ceb714c04eaa43c2fc12d65020f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API const char* Fubi::getUserDefinedCombinationRecognizerName </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>recognizerIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a user defined combination recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerIndex</td><td>index of the recognizer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the recognizer name or an empty string if the user is not found or the name not set </dd></dl>

</div>
</div>
<a class="anchor" id="ga91564b427870c0c6e2b74612c936b2c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned short Fubi::getCurrentUsers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00012.html">FubiUser</a> ***&#160;</td>
          <td class="paramname"><em>pUserContainer</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all current users with their tracking information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUserContainer</td><td>(=0) pointer where a pointer to the current users will be stored at The maximal size is <a class="el" href="a00046.html#ae110eb5577d96fb42a207d81b939a5aa" title="Maximum number of tracked users. ">Fubi::MaxUsers</a>, but the current size can be requested by leaving the Pointer at 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current number of users (= valid users in the container) </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e392f4ffccb8872502cd85005365abb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00012.html">FubiUser</a>* Fubi::getUser </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one user with his tracking information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>OpenNI id of the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the user data </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c5bde2bfb6fedc665f5d474574802cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getDepthResolution </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current depth resolution or -1, -1 if failed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width,height</td><td>[out] the resolution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6019b281270bcadd2dad4d53ee37104a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getRgbResolution </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current rgb resolution or -1, -1 if failed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width,height</td><td>[out] the resolution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3888db1df751672a0adc84c12cb6d336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getIRResolution </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current ir resolution or -1, -1 if failed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width,height</td><td>[out] the resolution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b80b38af330aee5ed11f3c521138e56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getFingerCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leftHand</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getMedianOfLastFrames</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOldConvexityDefectMethod</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of shown fingers detected at the hand of one user (REQUIRES OPENCV!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userID</td><td>OpenNI id of the user </td></tr>
    <tr><td class="paramname">leftHand</td><td>looks at the left instead of the right hand </td></tr>
    <tr><td class="paramname">getMedianOfLastFrames</td><td>uses the precalculated median of finger counts of the last frames (still calculates new one if there is no precalculation) </td></tr>
    <tr><td class="paramname">useOldConvexityDefectMethod</td><td>if true using old method that calculates the convexity defects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of shown fingers detected, 0 if there are none or there is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga228e6b8570a66f48bede527de9a54fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::enableFingerTracking </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leftHand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rightHand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useConvexityDefectMethod</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables finger tracking for the hands of one user If enabled the finger count will be tracked over time and the median of these value will be returned in case of a query (REQUIRES OPENCV!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userID</td><td>OpenNI id of the user </td></tr>
    <tr><td class="paramname">leftHand</td><td>enable/disable finger tracking for the left hand </td></tr>
    <tr><td class="paramname">rightHand</td><td>enable/disable finger tracking for the right hand </td></tr>
    <tr><td class="paramname">useConvexityDefectMethod</td><td>use the old method for extracting the users hand out of the depth image (not recommended) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga191014773bdd26032eed94deb8812fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::isUserInScene </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the user is currently seen in the depth image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userID</td><td>OpenNI id of the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7b03ac13fe291c3af8f8520c5af62199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::isUserTracked </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the user is currently tracked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userID</td><td>OpenNI id of the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20588f94621ed3116a4846ececf9651d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00035.html">FubiUser::TrackingData</a>* Fubi::getCurrentTrackingData </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the most current tracking info of the user (including all joint positions and orientations (local and global) and a timestamp) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userId</td><td>id of the user </td></tr>
    <tr><td class="paramname">filteredData</td><td>if true the returned data will be data smoothed by the filter configured in the sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the user tracking info struct </dd></dl>

</div>
</div>
<a class="anchor" id="gaa579c340e00b6a7474f7c32c9957f4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00035.html">FubiUser::TrackingData</a>* Fubi::getLastTrackingData </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filteredData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last tracking info of the user (one frame before the current one) (including all joint positions and orientations (local and global) and a timestamp) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userId</td><td>id of the user </td></tr>
    <tr><td class="paramname">filteredData</td><td>if true the returned data will be data smoothed by the filter configured in the sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the user tracking info struct </dd></dl>

</div>
</div>
<a class="anchor" id="ga67245098a7c8ecc865c25a9a2628ac82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getSkeletonJointPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00035.html">FubiUser::TrackingData</a> *&#160;</td>
          <td class="paramname"><em>trackingInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>confidence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>timeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localPosition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the skeleton joint position out of the tracking info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackingInfo</td><td>the trackinginfo struct to extract the info from </td></tr>
    <tr><td class="paramname">joint</td><td>the considered joint id </td></tr>
    <tr><td class="paramname">x,y,z</td><td>[out] where the position of the joint will be copied to </td></tr>
    <tr><td class="paramname">confidence</td><td>[out] where the confidence for this position will be copied to </td></tr>
    <tr><td class="paramname">timeStamp</td><td>[out] where the timestamp of this tracking info will be copied to (seconds since program start) </td></tr>
    <tr><td class="paramname">localPosition</td><td>if set to true, the function will return local position (vector from parent joint) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b22ff3d35913a083ed6d04900cb23f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getSkeletonJointOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00035.html">FubiUser::TrackingData</a> *&#160;</td>
          <td class="paramname"><em>trackingInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkeletonJoint::Joint&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>confidence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>timeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localOrientation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the skeleton joint orientation out of the tracking info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackingInfo</td><td>the trackinginfo struct to extract the info from </td></tr>
    <tr><td class="paramname">joint</td><td>the considered joint id </td></tr>
    <tr><td class="paramname">mat</td><td>[out] rotation 3x3 matrix (9 floats) </td></tr>
    <tr><td class="paramname">confidence</td><td>[out] the confidence for this position </td></tr>
    <tr><td class="paramname">timeStamp</td><td>[out] (seconds since program start) </td></tr>
    <tr><td class="paramname">localOrientation</td><td>if set to true, the function will local orientations (cleared of parent orientation) instead of globals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd25a37aa474a0ee5e7bd02b10d16484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API std::vector&lt;<a class="el" href="a00035.html">FubiUser::TrackingData</a>&gt;* Fubi::createTrackingDataVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty vector of UserTrackinginfo structs. </p>

</div>
</div>
<a class="anchor" id="gab5f0577998236d99ed4616d245ac6b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::releaseTrackingDataVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the formerly created vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector that will be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46d5b2315d989d4c71c28e178f6d1520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getTrackingDataVectorSize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector that we get the size of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33e600f406741feaa2ec95afbfe84221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00035.html">FubiUser::TrackingData</a>* Fubi::getTrackingData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00035.html">FubiUser::TrackingData</a> &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one element of the tracking info vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector that we get the element of </td></tr>
    <tr><td class="paramname">index</td><td>element index with the tracking data vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5ab274c287e417c7e1148dae10f68661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getClosestUserID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the OpenNI id of the user standing closest to the sensor (x-z plane) </p>

</div>
</div>
<a class="anchor" id="ga9a1417caa305f6fe1a63a35b64626293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API std::deque&lt;unsigned int&gt; Fubi::getClosestUserIDs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumUsers</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ids of all users order by their distance to the sensor (x-z plane) Closest user is at the front, user with largest distance or untracked users at the back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNumUsers</td><td>if greater than -1, the given number of closest users is additionally ordered from left to right position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a deque including the user ids </dd></dl>

</div>
</div>
<a class="anchor" id="gafccbdcafe946a4ad4fdb6ab37e4d9c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getClosestUserIDs </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>userIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumUsers</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ids of all users order by their distance to the sensor (x-z plane) Closest user is at the front, user with largest distance or untracked users at the back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userIds</td><td>an array big enough to receive the indicated number of user ids (<a class="el" href="a00046.html#ae110eb5577d96fb42a207d81b939a5aa" title="Maximum number of tracked users. ">Fubi::MaxUsers</a> at max) </td></tr>
    <tr><td class="paramname">maxNumUsers</td><td>if greater than -1, the given number of closest users is additionally ordered from left to right position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of user ids written into the array </dd></dl>

</div>
</div>
<a class="anchor" id="gabeea215207ee95a52c071ddba2446b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00012.html">FubiUser</a>* Fubi::getClosestUser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user standing closest to the sensor (x-z plane) </p>

</div>
</div>
<a class="anchor" id="ga814cfb3ee301f0ddea627cc4d7d8fb8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API std::deque&lt;<a class="el" href="a00012.html">FubiUser</a>*&gt; Fubi::getClosestUsers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumUsers</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all users order by their distance to the sensor (x-z plane) Closest user is at the front, user with largest distance or untracked users at the back If maxNumUsers is given, the given number of closest users is additionally ordered from left to right position. </p>

</div>
</div>
<a class="anchor" id="ga13799687356f1db17755cb24c79eddd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::clearUserDefinedRecognizers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops and removes all user defined recognizers. </p>

</div>
</div>
<a class="anchor" id="ga425aafd817409bff0b6a4dba05d897ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::updateTrackingData </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00032.html">Fubi::SkeletonJointPosition</a> *&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStamp</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00031.html">Fubi::SkeletonJointOrientation</a> *&#160;</td>
          <td class="paramname"><em>orientations</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">Fubi::SkeletonJointAcceleration</a> *&#160;</td>
          <td class="paramname"><em>accelerations</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current tracking info of one user (including all joint positions. Optionally the orientations and a timestamp) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userId</td><td>id of the user </td></tr>
    <tr><td class="paramname">positions</td><td>an array of the joint positions </td></tr>
    <tr><td class="paramname">timeStamp</td><td>the timestamp of the tracking value (if -1 an own timestamp will be created) </td></tr>
    <tr><td class="paramname">orientations</td><td>an array of the joint positions (if 0, the orientations will be approximated from the given positions) </td></tr>
    <tr><td class="paramname">accelerations</td><td>an array of joint accelerations (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabeab4817883aa7f0c76cacf73d1e561f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::updateTrackingData </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>skeleton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStamp</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>accelerations</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same function as before, but skeleton and acceleartion as a plain float array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userId</td><td>id of the user </td></tr>
    <tr><td class="paramname">skeleton</td><td>i.e. NUM_JOINTS * (position+orientation) with position, orientation all as 4 floats (x,y,z,conf) in milimeters or degrees </td></tr>
    <tr><td class="paramname">timeStamp</td><td>in seconds or -1 for self calculation </td></tr>
    <tr><td class="paramname">accelerations</td><td>i.e. NUM_JOINTS * (acceleartion) with accelerations ass 4 floats (x,y,z,conf) in milimeters / second </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee1f70097ed1bd7b1249fe4def6a4575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00036.html">Fubi::Vec3f</a> Fubi::realWorldToProjective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00036.html">Fubi::Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>realWorldVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xRes</em> = <code>640</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yRes</em> = <code>480</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hFOV</em> = <code>1.0144686707507438</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vFOV</em> = <code>0.78980943449644714</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate from real world coordinates (milimeters) to screen coordinates (pixels in the depth/rgb/ir image). Uses the data of a present sensor, or alternatively calculates the projection according to given sensor values, or to standard values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realWorldVec</td><td>vector with real world coordinates (in milimeters) </td></tr>
    <tr><td class="paramname">xRes</td><td>x resolution of the screen (depth/rgb/ir image) </td></tr>
    <tr><td class="paramname">yRes</td><td>y resolution of the screen (depth/rgb/ir image) </td></tr>
    <tr><td class="paramname">hFOV</td><td>the sensors horizontal field of view </td></tr>
    <tr><td class="paramname">vFOV</td><td>the sensors vertical field of view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with screen coordinates (pixels in the depth/rgb/ir image) </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d2f395cd7a7dc60679fd33a0dfdf2d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::realWorldToProjective </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>realWorldX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>realWorldY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>realWorldZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>screenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>screenY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>screenZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xRes</em> = <code>640</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yRes</em> = <code>480</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hFOV</em> = <code>1.0144686707507438</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vFOV</em> = <code>0.78980943449644714</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate from real world coordinates (milimeters) to screen coordinates (pixels in the depth/rgb/ir image). Uses the data of a present sensor, or alternatively calculates the projection according to given sensor values, or to standard values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realWorldX,realWorldY,realWorldZ</td><td>vector with real world coordinates (in milimeters) </td></tr>
    <tr><td class="paramname">screenX,screenY,screenZ</td><td>[out] vector with screen coordinates (pixels in the depth/rgb/ir image) </td></tr>
    <tr><td class="paramname">xRes</td><td>x resolution of the screen (depth/rgb/ir image) </td></tr>
    <tr><td class="paramname">yRes</td><td>y resolution of the screen (depth/rgb/ir image) </td></tr>
    <tr><td class="paramname">hFOV</td><td>the sensors horizontal field of view </td></tr>
    <tr><td class="paramname">vFOV</td><td>the sensors vertical field of view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53bf978e749e70265c9fe8c3720fe5d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::resetTracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resests the tracking of all users </p>

</div>
</div>
<a class="anchor" id="ga876a3e5feec186357ff6dc1219681d52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API double Fubi::getCurrentTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get time since program start in seconds </p>

</div>
</div>
<a class="anchor" id="ga08bcb8c2175b2e6b97d8346f0fab5302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::setFilterOptions </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minCutOffFrequency</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>velocityCutOffFrequency</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cutOffSlope</em> = <code>0.007f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the filtering options for smoothing the skeleton according to the 1 filter (still possible to get the unfiltered data) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minCutOffFrequency</td><td>(=1.0f) the minimum cutoff frequency for low pass filtering (=cut off frequency for a still joint) </td></tr>
    <tr><td class="paramname">velocityCutOffFrequency</td><td>(=1.0f) the cutoff frequency for low pass filtering the velocity </td></tr>
    <tr><td class="paramname">cutOffSlope</td><td>(=0.007f) how fast a higher velocity will higher the cut off frequency (-&gt;apply less smoothing with higher velocities) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc0c4dd71c2dfff1114bbd4b6ab7e8dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getFilterOptions </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>minCutOffFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>velocityCutOffFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>cutOffSlope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the filtering options for smoothing the skeleton according to the 1 filter (still possible to get the unfiltered data) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minCutOffFrequency</td><td>[out] the minimum cutoff frequency for low pass filtering (=cut off frequency for a still joint) </td></tr>
    <tr><td class="paramname">velocityCutOffFrequency</td><td>[out] the cutoff frequency for low pass filtering the velocity </td></tr>
    <tr><td class="paramname">cutOffSlope</td><td>[out] how fast a higher velocity will higher the cut off frequency (-&gt;apply less smoothing with higher velocities) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac947568af8590849e93cc40920bfa355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getCurrentCombinationRecognitionState </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>userID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInterrupted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInTransition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined combination recognizer for its current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the combination </td></tr>
    <tr><td class="paramname">userID</td><td>the user id of the user to be checked </td></tr>
    <tr><td class="paramname">numStates</td><td>[out] the full number of states of this recognizer </td></tr>
    <tr><td class="paramname">isInterrupted</td><td>[out] whether the recognizers of the current state are temporarly interrupted </td></tr>
    <tr><td class="paramname">isInTransition</td><td>[out] if the state has already passed its min duration and would be ready to transit to the next state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of current state (0..numStates-1), if &lt; 0 -&gt; error: -1 if first state not yet started, -2 user not found, -3 recognizer not found </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dc877f5059df7b4876e63754489dd6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API const char* Fubi::getCombinationRecognitionStateMetaInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get meta information of a state of one recognizers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the combination </td></tr>
    <tr><td class="paramname">stateIndex</td><td>the state index to get the meta info from </td></tr>
    <tr><td class="paramname">propertyName</td><td>the name of the property to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the requested meta info property as a string, or 0x0 on error </dd></dl>

</div>
</div>
<a class="anchor" id="ga7046f49f3541639b3b4a54e8c7c222cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API bool Fubi::initFingerSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00008.html#ae1e461c328e6b5085be4c952d478a7ee">Fubi::FingerSensorType::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offsetPosX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offsetPosY</em> = <code>-600.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offsetPosZ</em> = <code>200.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initalizes a finger sensor such as the leap motion for tracking fingers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the sensor type (see <a class="el" href="a00008.html" title="All supported finger tracking sensor types, need to be enabled in the FubiConfig.h Further installati...">FingerSensorType</a> definition) </td></tr>
    <tr><td class="paramname">offsetPosX,offsetPosY,offsetPosZ</td><td>position of the finger sensor in relation to a second sensor (e.g. the Kinect) to align the coordinate systems </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful initialized </dd></dl>

</div>
</div>
<a class="anchor" id="gafc26e60b890a0912890588cb4a9635e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getAvailableFingerSensorTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently available finger sensor types (defined in <a class="el" href="a00040.html" title="a header file containing defines for configuring the Fubi build ">FubiConfig.h</a> before compilation) </p>
<dl class="section return"><dt>Returns</dt><dd>an int composed of the currently available sensor types (see <a class="el" href="a00008.html" title="All supported finger tracking sensor types, need to be enabled in the FubiConfig.h Further installati...">FingerSensorType</a> enum for the meaning) </dd></dl>

</div>
</div>
<a class="anchor" id="gaed5686049a5fd2a5c33f426f12fc011a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00008.html#ae1e461c328e6b5085be4c952d478a7ee">Fubi::FingerSensorType::Type</a> Fubi::getCurrentFingerSensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the currently active sensor. </p>
<dl class="section return"><dt>Returns</dt><dd>the current sensor type </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b79b4a72aa84122b5c42911796888c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned short Fubi::getNumHands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of currently tracked hands. </p>
<dl class="section return"><dt>Returns</dt><dd>the current number of hands </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ac24ea386360e9e016faf1362f946c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API unsigned int Fubi::getHandID </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the hand id from the user index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the hand in the hand array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hand id of that user or 0 if not found </dd></dl>

</div>
</div>
<a class="anchor" id="gac8e37bd5fd0a07c5441fd4becd3a9fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::recognizeGestureOnHand </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>handId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined gesture or posture recognizer for its success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the recognizer return during its creation </td></tr>
    <tr><td class="paramname">handId</td><td>of the hand to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="gaee5b1f126f84f50afe579983f8448016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API Fubi::RecognitionResult::Result Fubi::getCombinationRecognitionProgressOnHand </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>handId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00009.html">FubiHand::FingerTrackingData</a> &gt; *&#160;</td>
          <td class="paramname"><em>handStates</em> = <code>0x0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnFilteredData</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">Fubi::RecognitionCorrectionHint</a> *&#160;</td>
          <td class="paramname"><em>correctionHint</em> = <code>0x0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined combination recognizer for its progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the combination </td></tr>
    <tr><td class="paramname">handId</td><td>of the hand to be checked </td></tr>
    <tr><td class="paramname">handStates</td><td>(= 0x0) [out] pointer to a vector of tracking data that represents the tracking information of the user during the recognition of each state </td></tr>
    <tr><td class="paramname">restart</td><td>(=true) if set to true, the recognizer automatically restarts, so the combination can be recognized again. </td></tr>
    <tr><td class="paramname">returnFilteredData</td><td>if true, the user states vector will contain filtered data </td></tr>
    <tr><td class="paramname">correctionHint</td><td>[out] on NOT_RECOGNIZED, this struct will contain information about why the recognition failed if wanted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RECOGNIZED in case of a succesful detection, TRACKING_ERROR if a needed joint is currently not tracked, NOT_RECOGNIZED else </dd></dl>

</div>
</div>
<a class="anchor" id="ga018413361603fd1fa846d9989fe58f8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::enableCombinationRecognitionHand </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>combinationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>handId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts or stops the recognition process of a user defined combination for one hand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">combinationName</td><td>name defined for this recognizer </td></tr>
    <tr><td class="paramname">handId</td><td>of the hand for which the recognizers should be modified </td></tr>
    <tr><td class="paramname">enable</td><td>if set to true, the recognizer will be started (if not already stared), else it stops </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef43f3531c29d8a9b93ad101ead024b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API int Fubi::getCurrentCombinationRecognitionStateForHand </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>handID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInterrupted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInTransition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a user defined combination recognizer for its current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the combination </td></tr>
    <tr><td class="paramname">handID</td><td>of the hand to be checked </td></tr>
    <tr><td class="paramname">numStates</td><td>[out] the full number of states of this recognizer </td></tr>
    <tr><td class="paramname">isInterrupted</td><td>[out] whether the recognizers of the current state are temporarly interrupted </td></tr>
    <tr><td class="paramname">isInTransition</td><td>[out] if the state has already passed its min duration and would be ready to transit to the next state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of current state (0..numStates-1), if &lt; 0 -&gt; error: -1 if first state not yet started, -2 user not found, -3 recognizer not found </dd></dl>

</div>
</div>
<a class="anchor" id="gab35b266a6e7f52c8672caeb35753cf62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::getFingerSensorOffsetPosition </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>xOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>yOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>zOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the offset position of the current finger sensor to the main sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xOffset,yOffset,zOffset</td><td>[out] a vector from the main sensor to the finger sensor, (0,0,0) if no sensor present </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea0cad63c3d9f92699370c44a2c5b5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API void Fubi::setFingerSensorOffsetPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the offset position of the current finger sensor to the main sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xOffset,yOffset,zOffset</td><td>the vector from the main sensor to the finger sensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf83ba1fdeaedc8f35d1cec740b88ab4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00024.html#a6f8ea6ba5cf047ff0fbe83b76cb70a86">Fubi::RecognizerTarget::Target</a> Fubi::getCombinationRecognizerTargetSensor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target sensor of a user defined combination recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the combination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the target sensor as defined in <a class="el" href="a00045.html" title="Utility functions and data structures. ">FubiUtils.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga876a93a4cb0174a59c7dedc7e10a2336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FUBI_API <a class="el" href="a00024.html#a6f8ea6ba5cf047ff0fbe83b76cb70a86">Fubi::RecognizerTarget::Target</a> Fubi::getRecognizerTargetSensor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>recognizerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target sensor for a recognizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recognizerName</td><td>name of the recognizer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the target sensor as defined in <a class="el" href="a00045.html" title="Utility functions and data structures. ">FubiUtils.h</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 10 2014 10:56:03 for Fubi by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
